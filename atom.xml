<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DebugTalk</title>
  <subtitle>探索一个软件工程师的无限可能</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://debugtalk.com/"/>
  <updated>2016-07-27T02:12:22.000Z</updated>
  <id>http://debugtalk.com/</id>
  
  <author>
    <name>九毫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于持续集成打包平台的Jenkins配置和构建脚本实现细节</title>
    <link href="http://debugtalk.com/post/iOS-Android-Packing-with-Jenkins-details/"/>
    <id>http://debugtalk.com/post/iOS-Android-Packing-with-Jenkins-details/</id>
    <published>2016-07-25T16:00:00.000Z</published>
    <updated>2016-07-27T02:12:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/post/iOS-Android-Packing-with-Jenkins/">《使用Jenkins搭建iOS/Android持续集成打包平台》</a>一文中，我对如何使用Jenkins搭建iOS/Android持续集成打包平台的基础概念和实施流程进行了介绍。本文作为配套，对搭建持续集成打包平台中涉及到的执行命令、构建脚本（build.py），以及Jenkins的配置进行详细的补充说明。</p>
<p>当然，如果你不关心技术实现细节，也可以完全不用理会，直接参照【开箱即用】部分按照步骤进行操作即可。</p>
<h2 id="关于iOS的构建"><a href="#关于iOS的构建" class="headerlink" title="关于iOS的构建"></a>关于iOS的构建</h2><p>对iOS源码进行构建，目标是要生成<code>.ipa</code>文件，即iOS应用安装包。</p>
<p>当前，构建方式主要包括两种：</p>
<ul>
<li><code>源码</code> -&gt; <code>.archive</code>文件 -&gt; <code>.ipa</code>文件</li>
<li><code>源码</code> -&gt; <code>.app</code>文件 -&gt; <code>.ipa</code>文件</li>
</ul>
<p>这两种方式的主要差异是生成的中间产物不同，对应的，两种构建方式采用的命令也不同。</p>
<h3 id="源码-gt-archive-gt-ipa"><a href="#源码-gt-archive-gt-ipa" class="headerlink" title="源码 -&gt; .archive -&gt; .ipa"></a><code>源码</code> -&gt; <code>.archive</code> -&gt; <code>.ipa</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># build archive file from source code</span></div><div class="line">xcodebuild \    <span class="comment"># xctool</span></div><div class="line">  -workspace <span class="variable">$&#123;WORKSPACE_PATH&#125;</span> \</div><div class="line">  -scheme <span class="variable">$&#123;SCHEME&#125;</span> \</div><div class="line">  -configuration <span class="variable">$&#123;CONFIGURATION&#125;</span> \</div><div class="line">  -sdk <span class="variable">$&#123;SDK&#125;</span></div><div class="line">  archive -archivePath <span class="variable">$&#123;archive_path&#125;</span></div></pre></td></tr></table></figure>
<p><code>archive</code>：打包命令，会生成一个<code>.xcarchive</code>的文件；archive命令需要接一个参数<code>-archivePath</code>，即存放Archive文件的目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># export ipa file from .archive</span></div><div class="line">xcodebuild -exportArchive \</div><div class="line">  -exportFormat format \</div><div class="line">  -archivePath xcarchivepath \</div><div class="line">  -exportPath destinationpath \</div><div class="line">  -exportProvisioningProfile profilename \</div><div class="line">  [-exportSigningIdentity identityname]</div><div class="line">  [-exportInstallerIdentity identityname]</div></pre></td></tr></table></figure>
<h3 id="源码-gt-app-gt-ipa"><a href="#源码-gt-app-gt-ipa" class="headerlink" title="源码 -&gt; .app -&gt; .ipa"></a><code>源码</code> -&gt; <code>.app</code> -&gt; <code>.ipa</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># build .app file from source code</span></div><div class="line">xcodebuild \    <span class="comment"># xctool</span></div><div class="line">  -workspace <span class="variable">$&#123;WORKSPACE_PATH&#125;</span> \</div><div class="line">  -scheme <span class="variable">$&#123;SCHEME&#125;</span> \</div><div class="line">  -configuration <span class="variable">$&#123;CONFIGURATION&#125;</span> \</div><div class="line">  -sdk <span class="variable">$&#123;SDK&#125;</span></div><div class="line">  -derivedDataPath build</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># convert .app file to ipa file</span></div><div class="line">xcrun \</div><div class="line">  -sdk iphoneos \</div><div class="line">  PackageApplication \</div><div class="line">  -v build/Release-iphoneos/xxx.app \</div><div class="line">  -o build/Release-iphoneos/xxx.ipa</div></pre></td></tr></table></figure>
<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p><strong>xcodebuild/xctool参数</strong>：</p>
<ul>
<li><code>-workspace</code>：需要打包的workspace，后面接的文件一定要是<code>.xcworkspace</code>结尾的；</li>
<li><code>-scheme</code>：需要打包的Scheme，一般与<code>$project_name</code>相同；</li>
<li><code>-sdk</code>：区分iphone device和Simulator；</li>
<li><code>-configuration</code>：需要打包的配置文件，我们一般在项目中添加多个配置，适合不同的环境，Release/Debug；</li>
<li><code>-derivedDataPath</code>：指定编译结果文件的存储路径；例如，指定<code>-derivedDataPath build</code>时，将在项目根目录下创建一个<code>build</code>文件夹，生成的<code>.app</code>文件将位于<code>build/Build/Products/Release-iphoneos</code>中。</li>
</ul>
<p>除了采用官方的<code>xcodebuild</code>命令，还可以使用由Facebook开发维护的<code>xctool</code>。<code>xctool</code>命令的使用方法基本与<code>xcodebuild</code>一致，但是输出的日志会清晰很多，而且还有许多其它优化，详情请参考<code>xctool</code>的官方文档。</p>
<p><strong>xcrun参数</strong>：</p>
<ul>
<li><code>-v</code>：指定<code>.app</code>文件的路径</li>
<li><code>-o</code>：指定生成<code>.ipa</code>文件的路径</li>
</ul>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p><strong>1、获取Targets、Schemes、Configurations参数</strong></p>
<p>在填写<code>target</code>/<code>workspace</code>/<code>scheme</code>/<code>configuration</code>等参数时，如果不知道该怎么填写，可以在项目根目录下执行<code>xcodebuild -list</code>命令，它会列出当前项目的所有可选参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">➜  Store_iOS git:(NPED) ✗ xcodebuild -list</div><div class="line">Information about project <span class="string">"Store"</span>:</div><div class="line">    Targets:</div><div class="line">        Store</div><div class="line">        StoreCI</div><div class="line"></div><div class="line">    Build Configurations:</div><div class="line">        Debug</div><div class="line">        Release</div><div class="line"></div><div class="line">    If no build configuration is specified and -scheme is not passed <span class="keyword">then</span> <span class="string">"Release"</span> is used.</div><div class="line"></div><div class="line">    Schemes:</div><div class="line">        Store</div><div class="line">        StoreCI</div></pre></td></tr></table></figure>
<p><strong>2、清除缓存文件</strong></p>
<p>在每次build之后，工程目录下会遗留一些缓存文件，以便下次build时减少编译时间。然而，若因为工程配置错误等问题造成编译失败后，下次再编译时就可能会受到缓存的影响。</p>
<p>因此，在持续集成构建脚本中，比较好的做法是在每次build之前都清理一下上一次编译遗留的缓存文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># clean before build</span></div><div class="line">xctool \</div><div class="line">  -workspace <span class="variable">$&#123;WORKSPACE_PATH&#125;</span> \</div><div class="line">  -scheme <span class="variable">$&#123;SCHEME&#125;</span> \</div><div class="line">  -configuration <span class="variable">$&#123;CONFIGURATION&#125;</span> \</div><div class="line">  clean</div></pre></td></tr></table></figure>
<p><code>clean</code>：清除编译产生的问题，下次编译就是全新的编译了</p>
<p><strong>3、处理Cocoapod依赖库</strong></p>
<p>另外一个需要注意的是，若项目是采用Cocoapod管理项目依赖，每次拉取最新代码后直接编译可能会报错。这往往是因为其他同事更新了依赖库（新增了第三方库或升级了某些库），而本地还采用之前的第三方库进行编译，从而会出现依赖库缺失或版本不匹配等问题。</p>
<p>应对的做法是，在每次build之前都更新一下Cocoapod。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Update pod repository</span></div><div class="line">pod repo update</div><div class="line"><span class="comment"># Install pod dependencies</span></div><div class="line">pod install</div></pre></td></tr></table></figure>
<p><strong>4、修改编译包的版本号</strong></p>
<p>通过持续集成打包，我们会得到大量的安装包。为了便于区分，比较好的做法是在App中显示版本号，并将版本号与Jenkins的<code>BUILD_NUMBER</code>关联起来。</p>
<p>例如，当前项目的主版本号为<code>2.6.0</code>，本次构建的<code>BUILD_NUMBER</code>为130，那么我们就可以将本次构建的App版本号设置为<code>2.6.0.130</code>。通过这种方式，我们可以通过App中显示的版本号快速定位到具体到构建历史，从而对应到具体的代码提交记录。</p>
<p>要实现对App版本号的设置，只需要在打包前对<code>Info.plist</code>文件中的<code>CFBundleVersion</code>和<code>CFBundleShortVersionString</code>进行修改即可。在Python中，利用<code>plistlib</code>库可以很方便地实现对<code>Info.plist</code>文件的读写。</p>
<p><strong>5、模拟器运行</strong></p>
<p>如果持续集成测试是要运行在iOS模拟器上，那么就需要构建生成<code>.app</code>文件。</p>
<p>在前面讲解的两种构建方式中，中间产物都包含了<code>.app</code>文件。对于以<code>.xcarchive</code>为中间产物的方式，生成的<code>.app</code>文件位于<code>output_dir/StoreCI_Release.xcarchive/Products/Applications/</code>目录中。</p>
<p>不过，这个<code>.app</code>文件在模拟器中还无法直接运行，还需要在Xcode中修改<code>Supported Platforms</code>，例如，将<code>iphoneos</code>更改为<code>iOS</code>。详细原因请参考<a href="/post/build-app-automated-test-platform-from-0-to-1-Appium-inspector-iOS-simulator/">《从0到1搭建移动App功能自动化测试平台（1）：模拟器中运行iOS应用》</a></p>
<h2 id="关于Android的构建"><a href="#关于Android的构建" class="headerlink" title="关于Android的构建"></a>关于Android的构建</h2><p>待续</p>
<h2 id="关于构建脚本"><a href="#关于构建脚本" class="headerlink" title="关于构建脚本"></a>关于构建脚本</h2><p>对于构建脚本（<a href="https://github.com/debugtalk/JenkinsTemplateForApp/blob/master/workspace/YourProject/Build_scripts/build.py" target="_blank" rel="external"><code>build.py</code></a>）本身，源码应该是最好的说明文档。</p>
<p>在<code>build.py</code>脚本中，主要实现的功能就四点：</p>
<ul>
<li>执行构建命令，编译生成<code>.ipa</code>文件，这部分包含了<code>关于iOS的构建</code>部分的全部内容；</li>
<li>构建时动态修改<code>Info.plist</code>，将编译包的版本号与Jenkins的BuildNumber关联起来；</li>
<li>上传<code>.ipa</code>文件至<code>pyger</code>/<code>fir.im</code>平台，并且做了失败重试机制；</li>
<li>解析<code>pyger</code>/<code>fir.im</code>平台页面中的二维码，将二维码图片保存到本地。</li>
</ul>
<p>需要说明的是，对于构建任务中常用的可配置参数，例如<code>BRANCH</code>/<code>SCHEME</code>/<code>CONFIGURATION</code>/<code>OUTPUT_FOLDER</code>等，需要在构建脚本中通过<code>OptionParser</code>的方式实现可传参数机制。这样我们不仅可以命令行中通过传参的方式灵活地调用构建脚本，也可以在Jenkins中实现参数传递。</p>
<p>之所以强调<code>常用的</code>可配置参数，这是为了尽可能减少参数数目，降低脚本调用的复杂度。像<code>PROVISIONING_PROFILE</code>和<code>pgyer/fir.im</code>账号这种比较固定的配置参数，就可以写死在脚本中。因此，在使用构建脚本（build.py）之前，需要先在脚本中配置下<code>PROVISIONING_PROFILE</code>和<code>pgyer/fir.im</code>账号。</p>
<p>另外还想多说一句，<code>pyger</code>/<code>fir.im</code>这类第三方平台在为我们提供便利的同时，稳定性不可控也是一个不得不考虑的问题。在我使用<code>pgyer</code>平台期间，就遇到了平台服务变动、接口时而不稳定出现502等问题。因此，最好的方式还是自行搭建一套类似的服务，反正我是打算这么做了。</p>
<h2 id="Jenkins的详细配置"><a href="#Jenkins的详细配置" class="headerlink" title="Jenkins的详细配置"></a>Jenkins的详细配置</h2><p>对于Jenkins的详细配置，需要补充说明的有四点。</p>
<h3 id="1、参数的传递"><a href="#1、参数的传递" class="headerlink" title="1、参数的传递"></a>1、参数的传递</h3><p>在构建脚本中，我们已经对常用的可配置参数实现了可传参机制。例如，在Terminal中可以通过如下形式调用构建脚本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python build.py --scheme SCHEME --workspace Store.xcworkspace --configuration CONFIGURATION --output OUTPUT_FOLDER</div></pre></td></tr></table></figure>
<p>那么我们在Jenkins中要怎样才能指定参数呢？</p>
<p>实际上，Jenkins针对项目具有参数化的功能。在项目的配置选项中，勾选<code>This project is parameterized</code>后，就可以为当前project添加多种类型的参数，包括：</p>
<ul>
<li>Boolean Parameter</li>
<li>Choice Parameter</li>
<li>Credentials Parameter</li>
<li>File Parameter</li>
<li>Multi-line String Parameter</li>
<li>Password Parameter</li>
<li>Run Parameter</li>
<li>String Parameter</li>
</ul>
<p>通常，我们可以选择使用<code>String Parameter</code>来定义自定义参数，并可对每个参数设置默认值。</p>
<p>当我们配置了<code>BRANCH</code>、<code>SCHEME</code>、<code>CONFIGURATION</code>、<code>OUTPUT_FOLDER</code>、<code>BUILD_VERSION</code>这几个参数后，我们就可以在<code>Build</code>配置区域的<code>Execute shell</code>通过如下形式来进行参数传递。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ python <span class="variable">$&#123;WORKSPACE&#125;</span>/Build_scripts/build.py \</div><div class="line">true--scheme <span class="variable">$&#123;SCHEME&#125;</span> \</div><div class="line">    --workspace <span class="variable">$&#123;WORKSPACE&#125;</span>/Store.xcworkspace \</div><div class="line">    --configuration <span class="variable">$&#123;CONFIGURATION&#125;</span> \</div><div class="line">    --output <span class="variable">$&#123;WORKSPACE&#125;</span>/<span class="variable">$&#123;OUTPUT_FOLDER&#125;</span> \</div><div class="line">    --build_version <span class="variable">$&#123;BUILD_VERSION&#125;</span>.<span class="variable">$&#123;BUILD_NUMBER&#125;</span></div></pre></td></tr></table></figure>
<p>可以看出，参数的传递方式很简单，只需要预先定义好了自定义参数，然后就可以通过<code>${Param}</code>的形式来进行调用了。</p>
<p>不过你也许会问，<code>WORKSPACE</code>和<code>BUILD_NUMBER</code>这两个参数我们并未进行定义，为什么也能进行调用呢？这是因为Jenkins自带部分与项目相关的环境变量，例如<code>BRANCH_NAME</code>、<code>JOB_NAME</code>等，这部分参数可以在shell脚本中直接进行调用。完整的环境变量可在<code>Jenkins_Url/env-vars.html/</code>中查看。</p>
<p>配置完成后，就可以在<code>Build with Parameters</code>中通过如下形式手动触发构建。</p>
<p><img src="/images/Jenkins_manul_build.jpg" alt=""></p>
<h3 id="2、修改build名称"><a href="#2、修改build名称" class="headerlink" title="2、修改build名称"></a>2、修改build名称</h3><p>在<code>Build History</code>列表中，构建任务的名称默认显示为按照build次数递增的<code>BUILD_NUMBER</code>。有时候我们可能想在build名称中包含更多的信息，例如包含当次构建的<code>SCHEME</code>和<code>CONFIGURATION</code>，这时我们就可以通过修改<code>BuildName</code>实现。</p>
<p>Jenkins默认不支持<code>BuildName</code>设置，但可通过安装<code>build-name-setter</code>插件进行实现。安装<code>build-name-setter</code>插件后，在配置页面的<code>Build Environment</code>栏目下会出现<code>Set Build Name</code>配置项，然后在<code>Build Name</code>中就可以通过环境变量参数来设置build名称。</p>
<p>例如，要将build名称设置为上面截图中的<code>StoreCI_Release_#130</code>样式，就可以在<code>Build Name</code>中配置为<code>${SCHEME}_${CONFIGURATION}_#${BUILD_NUMBER}</code>。</p>
<p>除了在<code>Build Name</code>中传递环境变量参数，<code>build-name-setter</code>还可以实现许多更加强大的自定义功能，大家可自行探索。</p>
<h3 id="3、展示二维码图片"><a href="#3、展示二维码图片" class="headerlink" title="3、展示二维码图片"></a>3、展示二维码图片</h3><p>然后再说下如何在<code>Build History</code>列表中展示每次构建对应的二维码图片。</p>
<p><img src="/images/Jenkins_build_history.jpg" alt=""></p>
<p>需要说明的是，在上图中，绿色框对应的内容是<code>BuildName</code>，我们可以通过<code>build-name-setter</code>插件来实现自定义配置；但是红色框已经不在<code>BuildName</code>的范围之内，而是对应的<code>BuildDescription</code>。</p>
<p>同样地，Jenkins默认不支持在构建过程中自动修改<code>BuildDescription</code>，需要通过安装<code>description setter plugin</code>插件来辅助实现。安装<code>description setter plugin</code>插件后，在配置页面的<code>Build</code>栏目下，<code>Add build step</code>中会出现<code>Set build description</code>配置项，添加该配置项后就会出现如下配置框。</p>
<p><img src="/images/Jenkins_set_build_description.jpg" alt=""></p>
<p>该功能的强大之处在于，它可以在构建日志中通过正则表达式来匹配内容，并将匹配到的内容添加到<code>BuildDescription</code>中去。</p>
<p>例如，我们想要展示的二维码图片是在每次构建过程中生成的，因此我们首先要获取到二维码图片文件。</p>
<p>我的做法是，在<code>build.py</code>中将蒲公英平台返回的应用下载页面地址和二维码图片地址打印到log中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">appDownloadPage: https://www.pgyer.com/035aaf10acf5dd7c279c4fe423a57674</div><div class="line">appQRCodeURL: https://o1wjx1evz.qnssl.com/app/qrcodeHistory/fe7a8c9051f0c7fc0affc78f40c20a4b5e4bdb4c77b91a29501f55fd9039c659</div><div class="line">Save QRCode image to file: /Users/Leo/.jenkins/workspace/DJI_Plus_Store_iOS/build_outputs/QRCode.png</div></pre></td></tr></table></figure>
<p>然后，在<code>Set build description</code>配置项的<code>Regular expression</code>就可以按照如下正则表达式进行匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">appDownloadPage: (.*)$</div></pre></td></tr></table></figure>
<p>接下来，就可以在<code>Description</code>中对匹配到的结果进行引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;img src=&apos;$&#123;BUILD_URL&#125;artifact/build_outputs/QRCode.png&apos;&gt;\n&lt;a href=&apos;\1&apos;&gt;Install Online&lt;/a&gt;</div></pre></td></tr></table></figure>
<p>在这里，我们用到了HTML的标签，而Jenkins的<code>Markup Formatter</code>默认是采用<code>Plain text</code>模式，因此还需要对Jenkins对系统配置进行修改，在<a href="/post/iOS-Android-Packing-with-Jenkins/">《使用Jenkins搭建iOS/Android持续集成打包平台》</a>中已进行了详细说明，在此就不再重复。</p>
<p>通过以上方式，就可以实现前面图片中的效果。</p>
<h3 id="4、收集编译成果物"><a href="#4、收集编译成果物" class="headerlink" title="4、收集编译成果物"></a>4、收集编译成果物</h3><p>在上面讲解的展示二维码图片一节中，用到了<code>${BUILD_URL}artifact/build_outputs/QRCode.png</code>一项，这里的URL就是用到了编译成果物收集后保存的路径。</p>
<p><code>Archives build artifacts</code>是Jenkins默认自带的功能，无需安装插件。该功能在配置页面的<code>Post-build Actions</code>栏目下，在<code>Add post-build action</code>的列表中选择添加<code>Archives build artifacts</code>。</p>
<p>添加后的配置页面如下图所示：</p>
<p><img src="/images/Jenkins_archive_the_artifacts.jpg" alt=""></p>
<p>通常，我们只需要配置<code>Files to archive</code>即可。定位文件时，可以通过正则表达式进行匹配，也可以调用项目的环境变量；多个文件通过逗号进行分隔。</p>
<p>例如，假如我们想收集<code>QRCode.png</code>、<code>StoreCI_Release.ipa</code>、<code>Info.plist</code>这三个文件，那么我们就可以通过如下表达式来进行指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$&#123;OUTPUT_FOLDER&#125;/*.ipa,$&#123;OUTPUT_FOLDER&#125;/QRCode.png,$&#123;OUTPUT_FOLDER&#125;/*.xcarchive/Info.plist</div></pre></td></tr></table></figure>
<p>当然，目标文件的具体位置是我们在构建脚本（<code>build.py</code>）中预先进行处理的。</p>
<p>通过这种方式，我们就可以实现在每次完成构建后将需要的文件收集起来进行存档，以便后续在Jenkins的任务页面中进行下载。</p>
<p><img src="/images/Jenkins_show_artifacts.jpg" alt=""></p>
<p>也可以直接通过归档文件的URL进行访问。例如，上图中<code>QRCode.png</code>的URL为<code>Jenkins_Url/job/JenkinsJobName/131/artifact/build_outputs/QRCode.png</code>，而<code>Jenkins_Url/job/JenkinsJobName/131/</code>即是<code>${BUILD_URL}</code>，因此可以直接通过<code>${BUILD_URL}artifact/build_outputs/QRCode.png</code>引用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，<a href="/post/iOS-Android-Packing-with-Jenkins/">《使用Jenkins搭建iOS/Android持续集成打包平台》</a>一文中涉及到的Jenkins配置和构建脚本实现细节均已补充完毕了。相信大家结合这两篇文章，应该会对如何使用Jenkins搭建iOS/Android持续集成打包平台的基础概念和实现细节都有一个比较清晰的认识。</p>
<p>对于还未完善的部分，我后续将在博客中进行更新。</p>
<p>操作手册请参考文章末尾的【开箱即用】部分，祝大家玩得愉快！</p>
<h2 id="开箱即用"><a href="#开箱即用" class="headerlink" title="开箱即用"></a>开箱即用</h2><p>GitHub地址：<a href="https://github.com/debugtalk/JenkinsTemplateForApp" target="_blank" rel="external">https://github.com/debugtalk/JenkinsTemplateForApp</a></p>
<h3 id="1、添加构建脚本"><a href="#1、添加构建脚本" class="headerlink" title="1、添加构建脚本"></a>1、添加构建脚本</h3><ul>
<li>在构建脚本中配置<code>PROVISIONING_PROFILE</code>和<code>pgyer/fir.im</code>账号；</li>
<li>在目标构建代码库的根目录中，创建<code>Build_scripts</code>文件夹，并将<code>build.py</code>拷贝到<code>Build_scripts</code>中；</li>
<li>将<code>Build_scripts/build.py</code>提交到项目中。</li>
</ul>
<p>除了与Jenkins实现持续集成，构建脚本还可单独使用，使用方式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ python <span class="variable">$&#123;WORKSPACE&#125;</span>/Build_scripts/build.py \</div><div class="line">true--scheme <span class="variable">$&#123;SCHEME&#125;</span> \</div><div class="line">    --workspace <span class="variable">$&#123;WORKSPACE&#125;</span>/Store.xcworkspace \</div><div class="line">    --configuration <span class="variable">$&#123;CONFIGURATION&#125;</span> \</div><div class="line">    --output <span class="variable">$&#123;WORKSPACE&#125;</span>/<span class="variable">$&#123;OUTPUT_FOLDER&#125;</span></div></pre></td></tr></table></figure>
<h3 id="2、运行jenkins，安装必备插件"><a href="#2、运行jenkins，安装必备插件" class="headerlink" title="2、运行jenkins，安装必备插件"></a>2、运行jenkins，安装必备插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nohup java -jar jenkins_located_path/jenkins.war &amp;</div></pre></td></tr></table></figure>
<h3 id="3、创建Jenkins-Job"><a href="#3、创建Jenkins-Job" class="headerlink" title="3、创建Jenkins Job"></a>3、创建Jenkins Job</h3><ul>
<li>在Jenkins中创建一个<code>Freestyle project</code>类型的Job，先不进行任何配置；</li>
<li>然后将<code>config.xml</code>文件拷贝到<code>~/.jenkins/jobs/YourProject/</code>中覆盖原有配置文件，重启Jenkins；</li>
<li>完成配置文件替换和重启后，刚创建好的Job就已完成了大部分配置；</li>
<li>在<code>Job Configure</code>中根据项目实际情况调整配置，其中<code>Git Repositories</code>是必须修改的，其它配置项可选择性地进行调整。</li>
</ul>
<h3 id="4、done！"><a href="#4、done！" class="headerlink" title="4、done！"></a>4、done！</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;/post/iOS-Android-Packing-with-Jenkins/&quot;&gt;《使用Jenkins搭建iOS/Android持续集成打包平台》&lt;/a&gt;一文中，我对如何使用Jenkins搭建iOS/Android持续集成打包平台的基础概念和实施流程进行
    
    </summary>
    
    
      <category term="Android" scheme="http://debugtalk.com/tags/Android/"/>
    
      <category term="Jenkins" scheme="http://debugtalk.com/tags/Jenkins/"/>
    
      <category term="iOS" scheme="http://debugtalk.com/tags/iOS/"/>
    
      <category term="CI" scheme="http://debugtalk.com/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to AppiumBooster</title>
    <link href="http://debugtalk.com/post/Introduction-to-AppiumBooster/"/>
    <id>http://debugtalk.com/post/Introduction-to-AppiumBooster/</id>
    <published>2016-07-19T16:00:00.000Z</published>
    <updated>2016-07-23T15:46:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AppiumBooster"><a href="#AppiumBooster" class="headerlink" title="AppiumBooster"></a>AppiumBooster</h2><p>AppiumBooster helps you to write automation testcases in tables, without writing a snippet of code.</p>
<h2 id="write-testcases"><a href="#write-testcases" class="headerlink" title="write testcases"></a>write testcases</h2><p>You can write testcases in any table tools, including MS Excel and iWork Numbers, and even in plain CSV format.</p>
<p>Take DJI+ Discover’s login and logout function as an example.</p>
<p><img src="/images/preview_login_and_logout.png" alt=""></p>
<p>In order to test these functions above, you can write testcases in tables like this.</p>
<p><img src="/images/testcase_login_and_logout.png" alt=""></p>
<p>After the testcases are finished, export to CSV format, and put the csv files under <code>ios/testcases/</code> directory.</p>
<p>That’s all you need to do, and now you are ready to run automation test on your app.</p>
<h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>Run the automation testcases is very easy. Just execute <code>ruby run.rb</code> in the project root directory.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  AppiumBooster git:(master) ✗ ruby run.rb</div></pre></td></tr></table></figure>
<p>AppiumBooster will load all the csv test suites and then excute each suite sequentially.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">➜  AppiumBooster git:(master) ✗ ruby run.rb</div><div class="line">initialize appium driver ...</div><div class="line">start appium driver ...</div><div class="line">alert accepted!</div><div class="line">======= start to run testcase suite: ./ios/testcases/Account-Login and Logout.csv =======</div><div class="line">load csv testcase file: ./ios/testcases/Account-Login and Logout.csv ...</div><div class="line">B------ Start to run testcase: Login with valid account</div><div class="line">step_1: Enter My Account Page</div><div class="line">control_element.click    ...    ✓</div><div class="line">uiviewMyAccount exsits?    ...    ✓</div><div class="line">step_2: Enter Login Page</div><div class="line">control_element.click    ...    ✓</div><div class="line">uiviewLogIn exsits?    ...    ✓</div><div class="line">step_3: Input Email Address</div><div class="line">control_element.type &apos;leo.lee@dji.com&apos;    ...    ✓</div><div class="line">step_4: Input Password</div><div class="line">control_element.type &apos;123456&apos;    ...    ✓</div><div class="line">step_5: Login</div><div class="line">control_element.click    ...    ✓</div><div class="line">tablecellMyMessage exsits?    ...    ✓</div><div class="line">step_6: Check if coupon popup window exists</div><div class="line">inner_screen.has_control &apos;btnViewMyCoupons&apos;    ...    ✓</div><div class="line">btnClose exsits?    ...    ✓</div><div class="line">step_7: Close coupon popup window</div><div class="line">control_element.click    ...    ✓</div><div class="line">!btnClose no longer exsits?    ...    ✓</div><div class="line">E------ Login with valid account</div><div class="line"></div><div class="line">B------ Start to run testcase: Logout</div><div class="line">step_1: Enter My Account Page</div><div class="line">control_element.click    ...    ✓</div><div class="line">uiviewMyAccount exsits?    ...    ✓</div><div class="line">step_2: Enter System Settings</div><div class="line">control_element.click    ...    ✓</div><div class="line">btnLogout exsits?    ...    ✓</div><div class="line">step_3: Click Logout</div><div class="line">control_element.click    ...    ✓</div><div class="line">Do you want to log out? exsits?    ...    ✓</div><div class="line">step_4: Confirm logout alert</div><div class="line">alert accepted!</div><div class="line">alert_accept    ...    ✓</div><div class="line">tablecellMyAccountLogin exsits?    ...    ✓</div><div class="line">E------ Logout</div><div class="line"></div><div class="line">============ all testcases have been executed. ============</div><div class="line">quit appium driver.</div></pre></td></tr></table></figure>
<h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h2><p>GitHub: <a href="https://github.com/debugtalk/AppiumBooster" target="_blank" rel="external">https://github.com/debugtalk/AppiumBooster</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AppiumBooster&quot;&gt;&lt;a href=&quot;#AppiumBooster&quot; class=&quot;headerlink&quot; title=&quot;AppiumBooster&quot;&gt;&lt;/a&gt;AppiumBooster&lt;/h2&gt;&lt;p&gt;AppiumBooster helps you to
    
    </summary>
    
    
      <category term="AutomationTest" scheme="http://debugtalk.com/tags/AutomationTest/"/>
    
      <category term="Appium" scheme="http://debugtalk.com/tags/Appium/"/>
    
      <category term="AppiumBooster" scheme="http://debugtalk.com/tags/AppiumBooster/"/>
    
  </entry>
  
  <entry>
    <title>使用Jenkins搭建iOS/Android持续集成打包平台</title>
    <link href="http://debugtalk.com/post/iOS-Android-Packing-with-Jenkins/"/>
    <id>http://debugtalk.com/post/iOS-Android-Packing-with-Jenkins/</id>
    <published>2016-06-27T16:00:00.000Z</published>
    <updated>2016-07-26T11:12:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>根据项目需求，现要在团队内部搭建一个统一的打包平台，实现对iOS和Android项目的打包。而且为了方便团队内部的测试包分发，希望在打包完成后能生成一个二维码，体验用户（产品、运营、测试等人员）通过手机扫描二维码后就能直接安装测试包。</p>
<p>该需求具有一定的普遍性，基本上所有开发APP的团队都可能会用到，因此我将整个需求实现的过程整理后形成此文，并且真正地做到了<code>零基础上手，到手即飞、开箱即用</code>，希望能对大家有所帮助。</p>
<p>首先，先给大家展示下平台建设完成后的整体效果：</p>
<p><img src="/images/Jenkins_Job_Overview.jpg" alt=""><br><img src="/images/Jenkins_Job_Build_View.jpg" alt=""></p>
<p>该平台主要实现的功能有3点：</p>
<ul>
<li>定期对GitHub仓库进行检测，若有更新则自动执行构建打包；</li>
<li>构建成功后根据ipa/apk生成二维码，并可在历史构建列表中展示各个版本的二维码，通过手机扫描二维码可直接安装对应版本；</li>
<li>在构建结果页面中展示当次构建的成果物（Artifact，如<code>.ipa</code>、<code>.app</code>、<code>.apk</code>、<code>info.plist</code>等文件），供有需要的用户进行下载。</li>
</ul>
<p>接下来，本文就开始对平台建设的完整实现过程进行详细介绍。</p>
<h2 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h2><p>Jenkins依赖于Java运行环境，因此需要首先安装<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="external">Java</a>。</p>
<p>安装Jenkins的方式有多种，可以运行对应系统类型的安装包，可以通过docker获取镜像，也可以直接运行<code>war</code>包。</p>
<p>我个人倾向于直接运行<code>war</code>包的形式，只需下载<code>jenkins.war</code>后，运行如下命令即可启动Jenkins。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nohup java -jar jenkins_located_path/jenkins.war --httpPort=88 &amp;</div></pre></td></tr></table></figure>
<p>如果不指定<code>httpPort</code>，Jenkins的默认端口为8080。</p>
<h2 id="Jenkins插件"><a href="#Jenkins插件" class="headerlink" title="Jenkins插件"></a>Jenkins插件</h2><p>Jenkins有非常多的插件，可以实现各种功能的扩展。</p>
<p>针对搭建的iOS/Android持续集成打包平台，我使用到了如下几个插件。</p>
<ul>
<li>GIT plugin</li>
<li>SSH Credentials Plugin</li>
<li>Git Changelog Plugin: 获取仓库提交的commit log</li>
<li>build-name-setter：用于修改Build名称</li>
<li>description setter plugin：用于在修改Build描述信息，在描述信息中增加显示QRCode（二维码）</li>
<li>Post-Build Script Plug-in：在编译完成后通过执行脚本实现一些额外功能</li>
<li>Xcode integration: iOS专用（可选）</li>
<li>Gradle plugin: Android专用（可选）</li>
</ul>
<p>安装方式也比较简单，直接在Jenkins的插件管理页面搜索上述插件，点击安装即可。</p>
<h2 id="创建项目（Job）"><a href="#创建项目（Job）" class="headerlink" title="创建项目（Job）"></a>创建项目（Job）</h2><p>在Jenkins中，构建项目以Job的形式存在，因此需要针对每个项目创建一个Job。有时候，一个项目中可能有多个分支同时在进行开发，为了分别进行构建，也可以针对每个分支创建一个Job。</p>
<p>创建Job的方式有多种，本次只需要创建<code>Freestyle project</code>类型的即可。</p>
<blockquote>
<p><code>Main page</code> -&gt; <code>New Item</code> -&gt; <code>Freestyle project</code></p>
</blockquote>
<p>对于一个持续集成打包平台，每次打包都由4步组成：触发构建、拉取代码、执行构建、构建后处理。对应的，在每个Job中也对应了这几项的配置。</p>
<h2 id="配置Git代码仓库"><a href="#配置Git代码仓库" class="headerlink" title="配置Git代码仓库"></a>配置Git代码仓库</h2><p>要对项目进行构建，配置项目的代码仓库是必不可少的。由于当前我们的项目托管在GitHub私有仓库中，因此在此需要对<code>Git</code>进行配置。</p>
<p>在<code>【Source Code Management】</code>配置栏目下，如果之前<code>GIT plugin</code>安装成功，则会出现<code>Git</code>选项。</p>
<p>配置Git代码仓库时，有三项是必须配置的：仓库URL地址（<code>Repository URL</code>）、仓库权限校验方式（<code>Credentials</code>），以及当前Job需要构建的代码分支（<code>Branches to build</code>）。</p>
<p>在配置<code>Repository URL</code>时，选择<code>HTTPS URL</code>或<code>SSH URL</code>均可。不过需要注意的是，<code>Credentials</code>要和<code>Repository URL</code>对应，也就是说：</p>
<ul>
<li>如果<code>Repository URL</code>是<code>HTTPS URL</code>形式的，那么<code>Credentials</code>就要采用GitHub用户名密码的校验方式；而且，如果在GitHub中开启了<code>2FA（two-factor authentication）</code>，那么还需要在GitHub中创建一个<code>Personal access token</code>，输入密码时将这个<code>Personal access token</code>作为密码进行输入。</li>
<li>如果<code>Repository URL</code>是<code>SSH URL</code>形式的，那么就需要先在Jenkins所在的服务器上创建一个<code>SSH</code>秘钥对，并将公钥添加到GitHub的<code>SSH keys</code>中，然后在填写<code>Credentials</code>时，选择<code>SSH Username with private key</code>的校验方式，填入GitHub Username、SSH私钥、以及创建<code>SSH</code>秘钥对时设置的<code>Passphrase</code>。</li>
</ul>
<p>如果对Git权限校验的概念还比较模糊，可以参考<a href="/post/head-first-git-authority-verification">《深入浅出Git权限校验》</a>。</p>
<p>在配置<code>Branches to build</code>时，可以采用多种形式，包括分支名称（<code>branchName</code>）、<code>tagName</code>、<code>commitId</code>等。其中分支名称的形式用的最多，例如，若是构建<code>master</code>分支，则填写<code>refs/heads/master</code>，若是构建<code>develop</code>分支，则填写<code>refs/heads/develop</code>。</p>
<p>除了以上关于Git的必填配置项，有时根据项目的实际情况，可能还需要对Jenkins的默认配置项进行修改。</p>
<p>比较常见的一种情况就是对<code>clone</code>的配置进行修改。</p>
<p>在Jenkins的默认配置中，<code>clone</code>代码时会拉取所有历史版本的代码，而且默认的超时时限只有10分钟。这就造成在某些项目中，由于代码量本身就比较大，历史版本也比较多，再加上网络环境不是特别好，Jenkins根本没法在10分钟之内拉取完所有代码，超时后任务就会被自动终止了（错误状态码143）。</p>
<p>这种问题的解决方式也很简单，无非就是两种思路，要么少拉取点代码（不获取历史版本），要么提高超时时限。对应的配置在<code>Advanced clone behaviours</code>中：</p>
<ul>
<li><code>Shallow clone</code>：勾选后不获取历史版本；</li>
<li><code>Timeout (in minutes) for clone and fetch operation</code>：配置后覆盖默认的超时时限。</li>
</ul>
<h2 id="配置构建触发器"><a href="#配置构建触发器" class="headerlink" title="配置构建触发器"></a>配置构建触发器</h2><p>代码仓库配置好了，意味着Jenkins具有了访问GitHub代码仓库的权限，可以成功地拉取代码。</p>
<p>那Jenkins什么时候执行构建呢？</p>
<p>这就需要配置构建触发策略，即构建触发器，配置项位于<code>【Build Triggers】</code>栏目。</p>
<p>触发器支持多种类型，常用的有：</p>
<ul>
<li>定期进行构建（Build periodically）</li>
<li>根据提交进行构建（Build when a change is pushed to GitHub）</li>
<li>定期检测代码更新，如有更新则进行构建（Poll SCM）</li>
</ul>
<p>构建触发器的选择为复合选项，若选择多种类型，则任一类型满足构建条件时就会执行构建工作。如果所有类型都不选择，则该<code>Jenkins Job</code>不执行自动构建，但可通过手动点击<code>【Build Now】</code>触发构建。</p>
<p>关于定时器（Schedule）的格式，简述如下：</p>
<p><code>MINUTE HOUR DOM MONTH DOW</code></p>
<ul>
<li>MINUTE: Minutes within the hour (0-59)</li>
<li>HOUR: The hour of the day (0-23)</li>
<li>DOM: The day of the month (1-31)</li>
<li>MONTH: The month (1-12)</li>
<li>DOW: The day of the week (0-7) where 0 and 7 are Sunday.</li>
</ul>
<p>通常情况下需要指定多个值，这时可以采用如下operator（优先级从上到下）：</p>
<ul>
<li><code>*</code>适配所有有效的值，若不指定某一项，则以<code>*</code>占位；</li>
<li><code>M-N</code>适配值域范围，例如7-9代表7/8/9均满足；</li>
<li><code>M-N/X</code>或<code>*/X</code>：以X作为间隔；</li>
<li><code>A,B,C</code>：枚举多个值。</li>
</ul>
<p>另外，为了避免多个任务在同一时刻同时触发构建，在指定时间段时可以配合使用<code>H</code>字符。添加<code>H</code>字符后，Jenkins会在指定时间段内随机选择一个时间点作为起始时刻，然后加上设定的时间间隔，计算得到后续的时间点。直到下一个周期时，Jenkins又会重新随机选择一个时间点作为起始时刻，依次类推。</p>
<p>为了便于理解，列举几个示例：</p>
<ul>
<li><code>H/15 * * * *</code>：代表每隔15分钟，并且开始时间不确定，这个小时可能是<code>:07,:22,:37,:52</code>，下一个小时就可能是<code>:03,:18,:33,:48</code>；</li>
<li><code>H(0-29)/10 * * * *</code>：代表前半小时内每隔10分钟，并且开始时间不确定，这个小时可能是<code>:04,:14,:24</code>，下一个小时就可能是<code>:09,:19,:29</code>；</li>
<li><code>H 23 * * 1-5</code>：工作日每晚23:00至23:59之间的某一时刻；</li>
</ul>
<h2 id="配置构建方式"><a href="#配置构建方式" class="headerlink" title="配置构建方式"></a>配置构建方式</h2><p>触发策略配置好之后，Jenkins就会按照设定的策略自动执行构建。但如何执行构建操作，这还需要我们通过配置构建方式来进行设定。</p>
<p>常用的构建方式是根据构建对象的具体类型，安装对应的插件，然后采用相应的构建方式。例如，若是构建<code>Android</code>应用，安装<code>Gradle plugin</code>之后，就可以选择<code>Invoke Gradle script</code>，然后采用<code>Gradle</code>进行构建；若是构建<code>iOS</code>应用，安装<code>Xcode integration</code>插件之后，就可以选择<code>Xcode</code>，然后选择<code>Xcode</code>进行构建。</p>
<p>该种方式的优势是操作简单，UI可视化，在场景不复杂的情况下可以快速满足需求。不过缺点就是依赖于插件已有的功能，如果场景较复杂时可能单个插件还无法满足需求，需要再安装其它插件。而且，有些插件可能还存在一些问题，例如对某些操作系统版本或XCode版本兼容不佳，出现问题时我们就会比较被动。</p>
<p>我个人更倾向于另外一种方式，就是自己编写打包脚本，在脚本中自定义实现所有的构建功能，然后在<code>Execute Shell</code>中执行。这种方式的灵活度更高，各种场景的构建需求都能满足，出现问题后也能自行快速修复。</p>
<p>另外，对于iOS应用的构建，还有一个需要额外关注的点，就是开发者证书的配置。</p>
<p>如果是采用<code>Xcode integration</code>插件进行构建，配置会比较复杂，需要在Jenkins中导入开发证书，并填写多个配置项。不过，如果是采用打包脚本进行构建的话，情况就会简单许多。只要在Jenkins所运行的计算机中安装好开发者证书，打包命令在Shell中能正常工作，那么在Jenkins中执行打包脚本也不会有什么问题。</p>
<h2 id="构建后处理"><a href="#构建后处理" class="headerlink" title="构建后处理"></a>构建后处理</h2><p>完成构建后，生成的编译成果物（ipa/apk）会位于指定的目录中。但是，如果要直接在手机中安装<code>ipa/apk</code>文件还比较麻烦，不仅在分发测试包时需要将好几十兆的安装包进行传送，体验用户在安装时也还需要通过数据线将手机与计算机进行连接，然后再使用PP助手或豌豆荚等工具进行安装。</p>
<p>当前比较优雅的一种方式是借助<code>蒲公英（pgyer）</code>或<code>fir.im</code>等平台，将<code>ipa/apk</code>文件上传至平台后由平台生成二维码，然后只需要对二维码链接进行分发，体验用户通过手机扫描二维码后即可实现快速安装，效率得到了极大的提升。</p>
<h3 id="上传安装包文件，生成二维码"><a href="#上传安装包文件，生成二维码" class="headerlink" title="上传安装包文件，生成二维码"></a>上传安装包文件，生成二维码</h3><p>不管是<code>蒲公英</code>还是<code>fir.im</code>，都有对应的Jenkins插件，安装插件后可以在<code>Post-build</code>中实现对安装包的上传。</p>
<p>除了使用Jenkins插件，<code>fir.im</code>还支持命令上传的方式，<code>蒲公英</code>还支持<code>HTTP Post</code>接口上传的方式。</p>
<p>我个人推荐采用命令或接口上传的方法，并在构建脚本中进行调用。灵活是一方面，更大的好处是如果上传失败后还能进行重试，这在网络环境不是很稳定的情况下极其必要。</p>
<p>Jenkins成功完成安装包上传后，<code>pgyer/fir.im</code>平台会生成一个二维码图片，并在响应中将图片的URL链接地址进行返回。</p>
<h3 id="展示二维码图片"><a href="#展示二维码图片" class="headerlink" title="展示二维码图片"></a>展示二维码图片</h3><p>二维码图片的URL链接有了，那要怎样才能将二维码图片展示在Jenkins项目的历史构建列表中呢？</p>
<p>这里需要用到另外一个插件，<code>description setter plugin</code>。安装该插件后，在<code>【Post-build Actions】</code>栏目中会多出<code>description setter</code>功能，可以实现构建完成后设置当次build的描述信息。这个描述信息不仅会显示在build页面中，同时也会显示在历史构建列表中。</p>
<p>有了这个前提，要将二维码图片展示在历史构建列表中貌似就可以实现了，能直观想到的方式就是采用<code>HTML</code>的<code>img</code>标签，将<code>&lt;img src=&#39;qr_code_url&#39;&gt;</code>写入到build描述信息中。</p>
<p>这个方法的思路是正确的，不过这么做以后并不会实现我们预期的效果。</p>
<p>这是因为Jenkins出于安全的考虑，所有描述信息的<code>Markup Formatter</code>默认都是采用<code>Plain text</code>模式，在这种模式下是不会对build描述信息中的HTML编码进行解析的。</p>
<p>要改变也很容易，<code>Manage Jenkins</code> -&gt; <code>Configure Global Security</code>，将<code>Markup Formatter</code>的设置更改为<code>Safe HTML</code>即可。</p>
<p>更改配置后，我们就可以在build描述信息中采用<code>HTML</code>的<code>img</code>标签插入图片了。</p>
<p>另外还需要补充一个点。如果是使用<code>蒲公英（pyger）</code>平台，会发现每次上传安装包后返回的二维码图片是一个短链接，神奇的是这个短连接居然是固定的（对同一个账号而言）。这个短连接总是指向最近生成的二维码图片，但是对于二维码图片的唯一URL地址，平台并没有在响应中进行返回。在这种情况下，我们每次构建完成后保存二维码图片的URL链接就没有意义了。</p>
<p>应对的做法是，每次上传完安装包后，通过返回的二维码图片短链接将二维码图片下载并保存到本地，然后在build描述信息中引用该图片在Jenkins中的地址即可。</p>
<h3 id="收集编译成果物（Artifacts）"><a href="#收集编译成果物（Artifacts）" class="headerlink" title="收集编译成果物（Artifacts）"></a>收集编译成果物（Artifacts）</h3><p>每次完成构建后，编译生成的文件较多，但是并不是所有的文件都是我们需要的。</p>
<p>通常情况下，我们可能只需要其中的部分文件，例如<code>.ipa/.app/.plist/.apk</code>等，这时我们可以将这部分文件单独收集起来，并在构建页面中展示出来，以便在需要时进行下载。</p>
<p>要实现这样一个功能，需要在<code>【Post-build Actions】</code>栏目中新增<code>Archive the artifacts</code>，然后在<code>Files to archive</code>中通过正则表达式指定成果物文件的路径。</p>
<p>设置完毕后，每次构建完成后，Jenkins会在<code>Console Output</code>中采用设定的正则表达式进行搜索匹配，如果能成功匹配到文件，则会将文件收集起来。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是对如何使用Jenkins搭建iOS/Android持续集成打包平台的基础概念和实施流程进行了介绍。对于其中涉及到的执行命令、构建脚本（build.py），以及Jenkins的详细配置，出于篇幅长度和阅读体验的考虑，并没有在文中进行详细展开。</p>
<p>为了实现真正的<code>开箱即用</code>，我将Jenkins的配置文件和构建脚本抽离出来形成一套模板，只需要导入到Jenkins中，然后针对具体的项目修改少量配置信息，即可将这一套持续集成打包平台运行起来，实现和文章开头插图中完全相同的功能效果。</p>
<p>详细内容请阅读<a href="/post/iOS-Android-Packing-with-Jenkins-details">《关于持续集成打包平台的Jenkins配置和构建脚本实现细节》</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;根据项目需求，现要在团队内部搭建一个统一的打包平台，实现对iOS和Android项目的打包。而且为了方便团队内部的测试包分发
    
    </summary>
    
    
      <category term="Android" scheme="http://debugtalk.com/tags/Android/"/>
    
      <category term="Jenkins" scheme="http://debugtalk.com/tags/Jenkins/"/>
    
      <category term="iOS" scheme="http://debugtalk.com/tags/iOS/"/>
    
      <category term="CI" scheme="http://debugtalk.com/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Git权限校验</title>
    <link href="http://debugtalk.com/post/head-first-git-authority-verification/"/>
    <id>http://debugtalk.com/post/head-first-git-authority-verification/</id>
    <published>2016-06-14T16:00:00.000Z</published>
    <updated>2016-07-23T07:25:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>借助上次“掉坑”的经历，我对Git权限校验的两种方式重头进行了梳理，形成了这篇总结记录。</p>
<p>在本地计算机与GitHub（或GitLab）进行通信时，传输主要基于两种协议，<code>HTTPS</code>和<code>SSH</code>，对应的仓库地址就是<code>HTTPS URLs</code>和<code>SSH URLs</code>。</p>
<p>首先需要强调的是，<code>HTTPS URLs</code>和<code>SSH URLs</code>对应的是两套完全独立的权限校验方式，主要的区别就是<code>HTTPS URLs</code>采用账号密码进行校验，<code>SSH URLs</code>采用<code>SSH</code>秘钥对进行校验。平时使用的时候我们可以根据实际情况，选择一种即可。</p>
<h2 id="HTTPS-URLs"><a href="#HTTPS-URLs" class="headerlink" title="HTTPS URLs"></a>HTTPS URLs</h2><p>GitHub官方推荐采用<code>HTTPS URLs</code>的方式，因为该种方式适用面更广（即使在有防火墙或代理的情况下也同样适用），使用更方便（配置更简单）。</p>
<p>采用<code>HTTPS URLs</code>地址<code>clone</code>/<code>fetch</code>/<code>pull</code>/<code>push</code>仓库时，事先无需对本地系统进行任何配置，只需要输入GitHub的账号和密码即可。不过如果每次都要手动输入账号密码，也是一件很繁琐的事情。</p>
<p>好在已经有多个机制可以让操作不用这么麻烦。</p>
<p>在Mac系统中，在启用<code>Keychain</code>机制的情况下，首次输入GitHub账号密码后，认证信息就会自动保存到系统的<code>Keychain</code>中，下次再次访问仓库时就会自动读取<code>Keychain</code>中保存的认证信息。</p>
<p>在非Mac系统中，虽然没有<code>Keychain</code>机制，但是Git提供了<code>credential helper</code>机制，可以将账号密码以cache的形式在内存中缓存一段时间（默认15分钟），或者以文件的形式存储起来（<code>~/.git-credentials</code>）。当然，Mac系统如果不启用<code>Keychain</code>机制，也可以采用这种方式。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cache credential in memory</span></div><div class="line">$ git config --global credential.helper cache</div><div class="line"><span class="comment"># store credential in ~/.git-credential</span></div><div class="line">$ git config --global credential.helper store</div></pre></td></tr></table></figure>
<p>在<code>credential.helper</code>设置为<code>store</code>的情况下，首次输入GitHub账号密码后，就会自动保存到<code>~/.git-credentials</code>文件中，保存形式为<code>https://user:pass@github.com</code>；下次再次访问仓库时就会自动读取<code>~/.git-credentials</code>中保存的认证信息。</p>
<p>另一个需要说明的情况是，如果在GitHub中开启了<code>2FA（two-factor authentication）</code>，那么在本地系统中输入GitHub账号密码时，不能输入原始的密码（即GitHub网站的登录密码），而是需要事先在GitHub网站中创建一个<code>Personal access token</code>，后续在访问代码仓库需要进行权限校验的时候，采用<code>access token</code>作为密码进行输入。</p>
<h2 id="SSH-URLs"><a href="#SSH-URLs" class="headerlink" title="SSH URLs"></a>SSH URLs</h2><p>除了<code>HTTPS URLs</code>，还可以采用<code>SSH URLs</code>的方式访问GitHub代码仓库。</p>
<p>采用<code>SSH URLs</code>方式之前，需要先在本地计算机中生成<code>SSH keypair</code>（秘钥对，包括私钥和公钥）。默认情况下，生成的秘钥位于<code>$HOME/.ssh/</code>目录中，文件名称分别为<code>id_rsa</code>和<code>id_rsa.pub</code>，通常无需修改，保持默认即可。不过，如果一台计算机中存在多个秘钥对，就需要修改秘钥文件名，名称没有强制的命名规范，便于自己辨识即可。</p>
<p>如下是创建秘钥对的过程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">➜ ssh-keygen -t rsa -b 4096 -C <span class="string">"mail@debugtalk.com"</span></div><div class="line">Generating public/private rsa key pair.</div><div class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/Leo/.ssh/id_rsa): /Users/Leo/.ssh/debugtalk_id_rsa</div><div class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): &lt;myPassphrase&gt;</div><div class="line">Enter same passphrase again: &lt;myPassphrase&gt;</div><div class="line">Your identification has been saved <span class="keyword">in</span> /Users/Leo/.ssh/debugtalk_id_rsa.</div><div class="line">Your public key has been saved <span class="keyword">in</span> /Users/Leo/.ssh/debugtalk_id_rsa.pub.</div><div class="line">The key fingerprint is:</div><div class="line">SHA256:jCyEEKjlCU1klROnuBg+UH08GJ1u252rQMADdD9kYMo mail@debugtalk.com</div><div class="line">The key<span class="string">'s randomart image is:</span></div><div class="line">+---[RSA 4096]----+</div><div class="line">|+*BoBO+.         |</div><div class="line">|o=oO=**          |</div><div class="line">|++E.*+o.         |</div><div class="line">|+ooo +o+         |</div><div class="line">|.o. ..+oS. .     |</div><div class="line">|  .  o. . o      |</div><div class="line">|      .    .     |</div><div class="line">|       .  .      |</div><div class="line">|        ..       |</div><div class="line">+----[SHA256]-----+</div></pre></td></tr></table></figure>
<p>在创建秘钥的过程中，系统还建议创建一个名为<code>passphrase</code>的东西，这是用来干嘛的呢？</p>
<blockquote>
<p>首先，单独采用密码肯定是不够安全的。如果密码太简单，那么就很容易被暴力破解，如果密码太复杂，那么用户就很难记忆，记录到小本子里面更不安全。</p>
<p>因此，<code>SSH keys</code>诞生了。<code>SSH</code>秘钥对的可靠性非常高，被暴力破解的可能性基本没有。不过，这要求用户非常谨慎地保管好私钥，如果别人使用你的计算机时偷偷地将你的私钥拷走了，那么就好比是别人拿到了你家里的钥匙，也能随时打开你家的门。</p>
<p>基于以上情况，解决办法就是在<code>SSH keys</code>之外再增加一个密码，即<code>passphrase</code>。只有同时具备<code>SSH private key</code>和<code>passphrase</code>的情况下，才能通过<code>SSH</code>的权限校验，这就大大地增加了安全性。当然，这个<code>passphrase</code>也不是必须的，在创建秘钥对时也可以不设置<code>passphrase</code>。</p>
<p>另外，如果每次权限校验时都要输入<code>passphrase</code>，这也是挺麻烦的。好在我们不用再担心这个问题，因为<code>ssh-agent</code>可以帮我们记住<code>passphrase</code>，Mac系统的Keychain也可以记住<code>passphrase</code>，这样我们在同一台计算机中就不用重新输入密码了。</p>
</blockquote>
<p>秘钥对创建好以后，私钥存放于本地计算机（<code>~/.ssh/id_rsa</code>），将公钥（<code>~/.ssh/id_rsa.pub</code>）中的内容添加至GitHub账户。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># copy the contents of id_rsa.pub to the clipboard</span></div><div class="line">➜ pbcopy &lt; ~/.ssh/id_rsa.pub</div><div class="line"></div><div class="line"><span class="comment"># paste to GitHub</span></div><div class="line"><span class="comment"># Login GitHub, 【Settings】-&gt;【SSH and GPG keys】-&gt;【New SSH Key】</span></div></pre></td></tr></table></figure>
<p>不过，如果此时检测本地计算机与GitHub的连接状态，会发现系统仍提示权限校验失败。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ssh -T git@github.com</div><div class="line">Permission denied (publickey).</div></pre></td></tr></table></figure>
<p>这是因为在本地计算机与GitHub建立连接的时候，实际上是本机计算机的<code>ssh-agent</code>与GitHub服务器进行通信。虽然本地计算机有了私钥，但是<code>ssh-agent</code>并不知道私钥存储在哪儿。因此，要想正常使用秘钥对，需要先将私钥加入到本地计算机的<code>ssh-agent</code>中（添加过程中需要输入<code>passphrase</code>）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># start ssh-agent in the background</span></div><div class="line">➜ <span class="built_in">eval</span> <span class="string">"<span class="variable">$(ssh-agent -s)</span>"</span></div><div class="line">Agent pid 78370</div><div class="line"></div><div class="line">➜ ssh-add ~/.ssh/id_rsa</div><div class="line">Enter passphrase <span class="keyword">for</span> /Users/Leo/.ssh/id_rsa: &lt;myPassphrase&gt;</div><div class="line">Identity added: /Users/Leo/.ssh/id_rsa (/Users/Leo/.ssh/id_rsa)</div></pre></td></tr></table></figure>
<p>添加完成后，就可以查看到当前计算机中存储的密钥。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ssh-add <span class="_">-l</span>                </div><div class="line">4096 SHA256:xRg49AgTxxxxxxxx8q2SPPOfxxxxxxxxRlBY /Users/Leo/.ssh/id_rsa (RSA)</div></pre></td></tr></table></figure>
<p>再次检测本地计算机与GitHub的连接状态，校验就正常通过了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜ ssh -T git@github.com</div><div class="line">Hi djileolee! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></div></pre></td></tr></table></figure>
<p>后续再进行<code>clone</code>/<code>fetch</code>/<code>pull</code>/<code>push</code>操作时，就可以正常访问GitHub代码仓库了，并且也不需要再重新输入账号密码。</p>
<p>而且，将私钥加入<code>ssh-agent</code>后，即使删除私钥文件，本地计算机仍可以正常访问GitHub代码仓库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">➜ rm -rf ~/.ssh</div><div class="line">➜ ssh-add <span class="_">-l</span>    </div><div class="line">4096 SHA256:xRg49AgTxxxxxxxx8q2SPPOfxxxxxxxxRlBY /Users/Leo/.ssh/id_rsa (RSA)</div><div class="line">➜ ssh -T git@github.com</div><div class="line">The authenticity of host <span class="string">'github.com (192.30.252.130)'</span> can<span class="string">'t be established.</span></div><div class="line">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</div><div class="line">Are you sure you want to continue connecting (yes/no)? yes</div><div class="line">Warning: Permanently added 'github.com,192.30.252.130<span class="string">' (RSA) to the list of known hosts.</span></div><div class="line">Hi djileolee! You've successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>
<p>只有执行<code>ssh-add -D</code>或<code>ssh-add -d pub_key</code>命令，将私钥从<code>ssh-agent</code>删除后，认证信息才会失效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜ ssh-add <span class="_">-d</span> ~/.ssh/id_rsa.pub</div><div class="line">Identity removed: /Users/Leo/.ssh/id_rsa.pub (mail@debugtalk.com)</div><div class="line">➜ ssh-add <span class="_">-l</span></div><div class="line">The agent has no identities.</div><div class="line">➜ ssh -T git@github.com</div><div class="line">Permission denied (publickey).</div></pre></td></tr></table></figure>
<h2 id="同时使用多个GitHub账号"><a href="#同时使用多个GitHub账号" class="headerlink" title="同时使用多个GitHub账号"></a>同时使用多个GitHub账号</h2><p>熟悉了<code>HTTPS URLs</code>和<code>SSH URLs</code>这两种校验方式之后，我们再来看之前遇到的问题。要想在一台计算机上同时使用多个GitHub账号访问不同的仓库，需要怎么做呢？</p>
<p>为了更好地演示，现假设有两个GitHub账号，<code>debugtalk</code>和<code>djileolee</code>，在两个账号中各自有一个仓库，<code>debugtalk/DroidMeter</code>和<code>DJIXY/MobileStore</code>（公司私有库）。</p>
<p>前面已经说过，<code>HTTPS URLs</code>和<code>SSH URLs</code>对应着两套独立的权限校验方式，因此这两套方式应该是都能单独实现我们的需求的。</p>
<p>不过在详细讲解Git权限校验的问题之前，我们先来回顾下Git配置文件的优先级。</p>
<h3 id="Git配置存储位置及其优先级"><a href="#Git配置存储位置及其优先级" class="headerlink" title="Git配置存储位置及其优先级"></a>Git配置存储位置及其优先级</h3><p><code>Unix-like</code>系统中，保存Git用户信息的主要有3个地方（Mac系统多一个<code>Keychain</code>）：</p>
<ul>
<li><code>/etc/gitconfig</code>：存储当前系统所有用户的git配置信息，使用带有<code>--system</code>选项的<code>git config</code>时，配置信息会写入该文件；</li>
<li><code>~/.gitconfig</code>或<code>~/.config/git/config</code>：存储当前用户的git配置信息，使用带有<code>--global</code>选项的<code>git config</code>时，配置信息会写入该文件；</li>
<li><code>Keychain Access</code>：在开启<code>Keychain</code>机制的情况下，进行权限校验后会自动将账号密码保存至<code>Keychain Access</code>。</li>
<li>仓库的Git目录中的config文件（即<code>repo/.git/config</code>）：存储当前仓库的git配置信息，在仓库中使用带有<code>--local</code>选项的<code>git config</code>时，配置信息会写入该文件；</li>
</ul>
<p>在优先级方面，以上4个配置项的优先级从上往下依次上升，即<code>repo/.git/config</code>的优先级最高，然后<code>Keychain Access</code>会覆盖<code>~/.gitconfig</code>中的配置，<code>~/.gitconfig</code>会覆盖<code>/etc/gitconfig</code>中的配置。</p>
<h3 id="基于SSH协议实现多账号共存"><a href="#基于SSH协议实现多账号共存" class="headerlink" title="基于SSH协议实现多账号共存"></a>基于<code>SSH</code>协议实现多账号共存</h3><p>先来看下如何采用<code>SSH URLs</code>实现我们的需求。</p>
<p>在处理多账号共存问题之前，两个账号均已分别创建<code>SSH</code>秘钥对，并且<code>SSH-key</code>均已加入本地计算机的<code>ssh-agent</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">➜ ssh-add <span class="_">-l</span></div><div class="line">4096 SHA256:lqujbjkWM1xxxxxxxxxxG6ERK6DNYj9tXExxxxxx8ew /Users/Leo/.ssh/dji_id_rsa (RSA)</div><div class="line">4096 SHA256:II2O9vZutdQr8xxxxxxxxxxD7EYvxxxxxxbynx2hHtg /Users/Leo/.ssh/id_rsa (RSA)</div></pre></td></tr></table></figure>
<p>在详细讲解多账号共存的问题之前，我们先来回想下平时在Terminal中与GitHub仓库进行交互的场景。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">➜  DroidMeter git:(master) git pull</div><div class="line">Already up-to-date.</div><div class="line">➜  DroidMeter git:(master) touch README.md</div><div class="line">➜  DroidMeter git:(master) ✗ git add .</div><div class="line">➜  DroidMeter git:(master) ✗ git commit -m <span class="string">"add README"</span></div><div class="line">➜  DroidMeter git:(master) git push</div><div class="line">Counting objects: 3, done.</div><div class="line">Delta compression using up to 4 threads.</div><div class="line">Compressing objects: 100% (2/2), done.</div><div class="line">Writing objects: 100% (3/3), 310 bytes | 0 bytes/s, done.</div><div class="line">Total 3 (delta 0), reused 0 (delta 0)</div><div class="line">To git@debugtalk:debugtalk/DroidMeter.git</div><div class="line">   7df6839..68d085b  master -&gt; master</div></pre></td></tr></table></figure>
<p>在操作过程中，本地计算机的<code>ssh-agent</code>与GitHub服务器建立了连接，并进行了账号权限校验。</p>
<p>当本地计算机只有一个GitHub账号时，这个行为并不难理解，系统应该会采用这个唯一的GitHub账号进行操作。那如果本地计算机中有多个Github账号时，系统是根据什么来判断应该选择哪个账号呢？</p>
<p>实际情况是，系统没法进行判断。系统只会有一个默认的账号，然后采用这个默认的账号去操作所有的代码仓库，当账号与仓库不匹配时，就会报权限校验失败的错误。</p>
<p>那要怎样才能让系统正确区分账号呢？这就需要我们手动进行配置，配置文件即是<code>~/.ssh/config</code>。</p>
<p>创建<code>~/.ssh/config</code>文件，在其中填写如下内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># debugtalk</span></div><div class="line">Host debugtalk</div><div class="line">    HostName github.com</div><div class="line">    User git</div><div class="line">    IdentityFile ~/.ssh/id_rsa</div><div class="line"></div><div class="line"><span class="comment"># DJI</span></div><div class="line">Host djileolee</div><div class="line">    HostName github.com</div><div class="line">    User git</div><div class="line">    IdentityFile ~/.ssh/dji_id_rsa</div></pre></td></tr></table></figure>
<p>要理解以上配置文件的含义并不难，我们可以对比看下两个项目的<code>SSH URLs</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git@github.com:debugtalk/DroidMeter.git</div><div class="line">git@github.com:DJISZ/Store_Android.git</div></pre></td></tr></table></figure>
<p>其中，<code>git</code>是本地<code>ssh-agent</code>与GitHub服务器建立<code>SSH</code>连接采用的用户名（即<code>User</code>），<code>github.com</code>是GitHub服务器的主机（即<code>HostName</code>）。</p>
<p>可以看出，如果采用原始的<code>SSH URLs</code>，由于<code>User</code>和<code>HostName</code>都相同，本地计算机并不知道应该采用哪个<code>SSH-key</code>去建立连接。</p>
<p>因此，通过创建<code>~/.ssh/config</code>文件，在<code>Host</code>中进行区分，然后经过<code>CNAME</code>映射到<code>HostName</code>，然后分别指向不同的<code>SSH-key</code>，即<code>IdentityFile</code>。由于<code>HostName</code>才是真正指定GitHub服务器主机的字段，因此这么配置不会对本地<code>ssh-agent</code>连接GitHub主机产生影响，再加上<code>Host</code>别名指向了不同的<code>SSH-key</code>，从而实现了对两个GitHub账号的分离。</p>
<p>配置完毕后，两个GitHub账号就可以通过<code>Host</code>别名来进行区分了。后续再与GitHub服务器进行通信时，就可以采用<code>Host</code>别名代替原先的<code>github.com</code>。例如，测试本地<code>ssh-agent</code>与GitHub服务器的连通性时，可采用如下方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ ssh -T git@debugtalk</div><div class="line">Hi debugtalk! You have successfully authenticated, but GitHub does not provide shell access.</div><div class="line">➜ ssh -T git@djileolee</div><div class="line">Hi djileolee! You have successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure>
<p>可以看出，此时两个账号各司其职，不会再出现混淆的情况。</p>
<p>不过，我们还遗漏了很重要的一点。在本地代码仓库中执行<code>push</code>/<code>pull</code>/<code>fetch</code>等操作的时候，命令中并不会包含<code>Host</code>信息，那系统怎么知道我们要采用哪个GitHub账号进行操作呢？</p>
<p>答案是，系统还是没法判断，需要我们进行配置指定。</p>
<p>显然，不同的仓库可能对应着不同的GitHub账号，因此这个配置不能配置成全局的，而只能在各个项目中分别进行配置，即<code>repo/.git/config</code>文件。</p>
<p>配置的方式如下：</p>
<p>在<code>debugtalk/DroidMeter</code>仓库中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ git remote add origin git@debugtalk:debugtalk/DroidMeter.git</div></pre></td></tr></table></figure>
<p>在<code>DJIXY/MobileStore.git</code>仓库中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ git remote add origin git@djileolee:DJIXY/MobileStore.git</div></pre></td></tr></table></figure>
<p>配置的原理也很容易理解，就是将仓库的<code>Host</code>更换为之前设置的别名。添加完毕后，后续再在两个仓库中执行任何<code>git</code>操作时，系统就可以选择正确的<code>SSH-key</code>与GitHub服务器进行交互了。</p>
<h3 id="基于HTTPS协议实现多账号共存"><a href="#基于HTTPS协议实现多账号共存" class="headerlink" title="基于HTTPS协议实现多账号共存"></a>基于<code>HTTPS</code>协议实现多账号共存</h3><p>再来看下如何采用<code>HTTPS URLs</code>实现我们的需求。</p>
<p>有了前面的经验，我们的思路就清晰了许多。采用<code>HTTPS URLs</code>的方式进行Git权限校验后，系统会将GitHub账号密码存储到<code>Keychain</code>中（Mac系统），或者存储到<code>~/.git-credentials</code>文件中（<code>Git credential helper</code>）。</p>
<p>不管是存储到哪里，我们面临的问题都是相同的，即如何在代码仓库中区分采用哪个GitHub账号。</p>
<p>配置的方式其实也很简单：</p>
<p>在<code>debugtalk/DroidMeter</code>仓库中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ git remote add origin https://debugtalk@github.com/debugtalk/DroidMeter.git</div></pre></td></tr></table></figure>
<p>在<code>DJIXY/MobileStore.git</code>仓库中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜ git remote add origin https://djileolee@github.com/DJIXY/MobileStore.git</div></pre></td></tr></table></figure>
<p>配置的原理也很容易理解，将GitHub用户名添加到仓库的Git地址中，这样在执行git命令的时候，系统就会采用指定的GitHub用户名去<code>Keychain</code>或<code>~/.git-credentials</code>中寻找对应的认证信息，账号使用错乱的问题也就不复存在了。</p>
<p><code>Done!</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;借助上次“掉坑”的经历，我对Git权限校验的两种方式重头进行了梳理，形成了这篇总结记录。&lt;/p&gt;
&lt;p&gt;在本地计算机与GitHub（或GitLab）进行通信时，传输主要基于两种协议，&lt;code&gt;HTTPS&lt;/code&gt;和&lt;code&gt;SSH&lt;/code&gt;，对应的仓库地址就是&lt;
    
    </summary>
    
    
      <category term="Git" scheme="http://debugtalk.com/tags/Git/"/>
    
      <category term="SSH" scheme="http://debugtalk.com/tags/SSH/"/>
    
      <category term="HTTPS" scheme="http://debugtalk.com/tags/HTTPS/"/>
    
      <category term="权限校验" scheme="http://debugtalk.com/tags/%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>GitHub权限校验失败给我的启发</title>
    <link href="http://debugtalk.com/post/trap-in-GitHub-authority-verification/"/>
    <id>http://debugtalk.com/post/trap-in-GitHub-authority-verification/</id>
    <published>2016-06-13T16:00:00.000Z</published>
    <updated>2016-07-23T07:25:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>众所周知，在GitHub中，每个仓库都有两个地址，分别基于<code>HTTPS</code>协议和<code>SSH</code>协议，两个协议对应的URL地址（repository_url）形式如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># HTTPS</span></div><div class="line">https://github.com/DJIXY/MobileStore.git</div><div class="line"><span class="comment"># SSH</span></div><div class="line">git@github.com:DJIXY/MobileStore.git</div></pre></td></tr></table></figure>
<p>正常情况下，只要在本地正确地配置好了<code>git</code>账号，采用这两个地址中的任意一个，都可以通过<code>git clone repository_url</code>获取代码。</p>
<p>但最近我在Macbook Air中<code>clone</code>公司托管在GitHub私有库中的代码时，发现无法通过<code>HTTPS</code>协议的地址<code>clone</code>代码，始终提示<code>remote: Repository not found.</code>的错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ git <span class="built_in">clone</span> https://github.com/DJIXY/MobileStore.git</div><div class="line">Cloning into <span class="string">'MobileStore'</span>...</div><div class="line">remote: Repository not found.</div><div class="line">fatal: repository <span class="string">'https://github.com/DJIXY/MobileStore.git/'</span> not found</div></pre></td></tr></table></figure>
<p>首先，这个代码仓库是确实存在的，而且地址肯定也是没有问题的，通过URL地址也能在浏览器中访问到对应的GitHub仓库页面。</p>
<p>其次，在本地对<code>git</code>的配置也是没有问题的，通过<code>SSH</code>协议的地址是可以正常<code>clone</code>代码的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">➜ git <span class="built_in">clone</span> git@github.com:DJIXY/MobileStore.git</div><div class="line">Cloning into <span class="string">'MobileStore'</span>...</div><div class="line">Warning: Permanently added the RSA host key <span class="keyword">for</span> IP address <span class="string">'192.30.252.131'</span> to the list of known hosts.</div><div class="line">remote: Counting objects: 355, done.</div><div class="line">remote: Compressing objects: 100% (3/3), done.</div></pre></td></tr></table></figure>
<p>并且，如果在<code>HTTPS</code>协议的URL地址中加上GitHub账号，也是可以正常<code>clone</code>代码的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ git <span class="built_in">clone</span> https://djileolee@github.com/DJIXY/MobileStore.git</div><div class="line">Cloning into <span class="string">'MobileStore'</span>...</div><div class="line">remote: Counting objects: 355, done.</div><div class="line">remote: Compressing objects: 100% (3/3), done.</div></pre></td></tr></table></figure>
<p>更奇怪的是，在我的另一台Mac Mini中，采用同样的账号配置，两种协议的URL地址却都能正常<code>clone</code>代码，仔细地对比了两台电脑的<code>git</code>配置，都是一样的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜ cat ~/.git-credentials</div><div class="line">https://djileolee:340d247cxxxxxxxxf39556e38fe2b0baxxxxxxxx@github.com</div><div class="line">➜</div><div class="line">➜ cat ~/.gitconfig</div><div class="line">[credential]</div><div class="line">truehelper = store</div></pre></td></tr></table></figure>
<p>那问题出在哪儿呢？</p>
<h2 id="定位分析"><a href="#定位分析" class="headerlink" title="定位分析"></a>定位分析</h2><p>通过Google得知，产生<code>remote: Repository not found.</code>报错的原因主要有两个，一是仓库地址错误，二是权限校验不通过。显然，第一个原因可以直接排除，在Macbook Air中出现该问题应该就是账号权限校验失败造成的。</p>
<p>对背景描述中的现象进行整理，重点关注两个疑点：</p>
<ul>
<li>通过<code>HTTPS</code>协议的URL地址进行<code>git clone</code>时，系统没有提示让输入用户名密码，就直接返回权限校验失败的异常；</li>
<li>在<code>HTTPS</code>协议的URL地址中加上GitHub用户名，就可以正常<code>clone</code>，而且，系统也没有提示输入密码。</li>
</ul>
<p>这说明，在系统中的某个地方，应该是保存了GitHub账号密码的，所以在未指定账号的情况下，<code>git clone</code>时系统就不再要求用户输入账号密码，而是直接读取那个保存好的账号信息；但是，那个保存的GitHub账号密码应该是存在问题的，这就造成采用那个账号信息去GitHub校验时无法通过，从而返回异常报错。</p>
<p>基于以上推测，寻找问题根源的当务之急是找到保存GitHub账号密码的地方。</p>
<p>通过查看Git官方文档，存储Git用户信息的地方有三个：</p>
<ul>
<li><code>/etc/gitconfig</code>：存储当前系统所有用户的git配置信息；</li>
<li><code>~/.gitconfig</code>或<code>~/.config/git/config</code>：存储当前用户的git配置信息；</li>
<li>仓库的Git目录中的config文件（即<code>repo/.git/config</code>）：存储当前仓库的git配置信息。</li>
</ul>
<p>这三个配置项的优先级从上往下依次上升，即<code>repo/.git/config</code>会覆盖<code>~/.gitconfig</code>中的配置，<code>~/.gitconfig</code>会覆盖<code>/etc/gitconfig</code>中的配置。</p>
<p>回到当前问题，由于还没有进入到具体的Git仓库，因此<code>repo/.git/config</code>可直接排除；然后是查看当前用户的git配置，在当前用户HOME目录下没有<code>~/.config/git/config</code>文件，只有<code>~/.gitconfig</code>，不过在<code>~/.gitconfig</code>中并没有账号信息；再去查看系统级的git配置信息，即<code>/etc/gitconfig</code>文件，但发现当前系统中并没有该文件。</p>
<p>找遍了Git用户信息可能存储的地方，都没有看到账号配置信息，那还可能存储在哪儿呢？</p>
<p>这时基本上是毫无思路了，只能靠各种胡乱猜测，甚至尝试采用Wireshark分别在两台Mac上对<code>git clone</code>的过程进行抓包，对比通讯数据的差异，但都没有找到答案。</p>
<p>最后，无意中想到了Mac的<code>Keychain</code>机制。在Mac OSX的<code>Keychain</code>中，可以保存用户的账号密码等<code>credentials</code>，那git账号会不会也保存到<code>Keychain</code>中了呢？</p>
<p>在Macbook Air中打开<code>Keychain Access</code>应用软件，搜索<code>github</code>，果然发现存在记录。</p>
<p><img src="/images/Mac_Keychain_GitHub.jpg" alt=""></p>
<p>而且，<code>github.com</code>这一项还存在两条记录。一条是我的个人账号<code>debugtalk</code>，另一条是公司的工作账号<code>djileolee</code>。</p>
<p><strong>至此，真相大白！！！</strong></p>
<p>在我的Macbook Air中，<code>Keychain Access</code>中保存了我的GitHub个人账号（<code>debugtalk</code>），该账号是没有权限访问公司私有仓库的。但是在Terminal中执行<code>git clone</code>命令时，系统优先读取了我的个人账号，并用该账号向GitHub发起校验请求，从而造成读取公司私有仓库时权限校验失败。然而，在<code>HTTPS</code>协议的URL地址中加上GitHub工作账号（<code>djileolee</code>）时，由于此时指定了账号名称，因此在<code>Keychain</code>中读取账号信息时就可以找到对应账号（包含密码），并且在无需输入密码的情况下就能成功通过GitHub的权限校验，进而成功<code>clone</code>得到代码。</p>
<p>原因弄清楚之后，解决方式就很简单了，在<code>Keychain</code>中删除个人账号，然后就正常了。</p>
<h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><p>但是，问题真的解决了么？</p>
<p>并没有！</p>
<p>简单粗暴地在Keychain中将个人GitHub账号删除了，虽然再次访问公司代码仓库时正常了，那我要再访问个人仓库时该怎么办呢？</p>
<p>貌似并没有清晰的思路。虽然网上也有不少操作指导教程，但是对于操作背后的原理，还是有很多不清晰的地方。</p>
<p>再回到前面的背景描述，以及定位问题的整个过程，不由地悲从中来。使用GitHub好歹也有好几年了，但是连最基本的概念都还一头雾水，所以遇到问题后只能靠瞎猜，东碰西撞，最后瞎猫碰到死耗子。</p>
<p>GitHub的<code>HTTPS</code>协议和<code>SSH</code>协议，这本来就对应着两套完全独立的权限校验方式，而我在<code>HTTPS</code>协议不正常的情况下还去查看<code>SSH</code>协议，这本来就实属多余。</p>
<p>借助这次“掉坑”的经历，我对<code>Git</code>权限校验的两种方式重头进行了梳理，并单独写了一篇博客，《深入浅出Git权限校验》，虽然花了些时间，但总算是扫清了萦绕多年的迷雾，感觉倍儿爽！</p>
<p>如果你也对<code>Git的权限校验</code>没有清晰的了解，遇到权限校验出错时只能“换一种方法试试”，也不知道怎么让一台计算机同时支持多个GitHub账号，那么也推荐看下那篇博客。</p>
<p>在微信公众号<code>debugtalk</code>中输入<code>Git权限校验</code>，获取《深入浅出Git权限校验》。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;众所周知，在GitHub中，每个仓库都有两个地址，分别基于&lt;code&gt;HTTPS&lt;/code&gt;协议和&lt;code&gt;SSH&lt;/c
    
    </summary>
    
    
      <category term="GitHub" scheme="http://debugtalk.com/tags/GitHub/"/>
    
      <category term="SSH" scheme="http://debugtalk.com/tags/SSH/"/>
    
      <category term="HTTPS，权限校验" scheme="http://debugtalk.com/tags/HTTPS%EF%BC%8C%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>关于促销活动页面测试的那些事儿</title>
    <link href="http://debugtalk.com/post/promotion-page-test/"/>
    <id>http://debugtalk.com/post/promotion-page-test/</id>
    <published>2016-06-08T16:00:00.000Z</published>
    <updated>2016-07-23T07:26:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章来说说促销活动页面测试的那些事儿。</p>
<h2 id="什么是促销活动页面？"><a href="#什么是促销活动页面？" class="headerlink" title="什么是促销活动页面？"></a>什么是促销活动页面？</h2><p>通常电商平台在节假日会做一些促销活动，而活动的宣传方式，主要会采用H5静态页面的形式，也就是本文中要讲的促销活动页面。</p>
<p>这些活动页面的特点是元素构成很简单，在页面中只包含一些促销商品的图片及其价格，而且价格往往都是写死在页面中，不会涉及到从数据库中读取，完完全全的静态页面；当然，促销活动页面的目的是将用户流量导向电商平台，因此在页面的图片或购买按钮背后会配上URL链接，用户点击链接后会跳转至电商平台对应的购买页面，活动页面也就完成了使命，这往往就是活动页面的全部内容。</p>
<p>这么看来，促销活动页面跟街上发的传单非常相似，只是传单是纸质的，而活动页面是网页的罢了。</p>
<h2 id="促销活动页面为什么要这么做呢？"><a href="#促销活动页面为什么要这么做呢？" class="headerlink" title="促销活动页面为什么要这么做呢？"></a>促销活动页面为什么要这么做呢？</h2><p>四方面原因。</p>
<p>第一，促销活动页面的目的性很强，就是为了主推几款特价商品，因此，商品和价格完全写死也不会有任何问题。</p>
<p>第二，促销活动页面的时效性很强，为促销活动而生，生命周期就那么几天，促销活动结束后这个活动页面也就作废了，因此也不用考虑复用的问题。</p>
<p>第三，从投入的人力成本和工作量考虑，促销活动页面的制作只需要设计师和前端工程师就能完成，无需后台开发人员进行配合，也无需对当前的电商平台进行任何功能调整。</p>
<p>第四，电商平台在做促销活动时，往往会通过各种渠道进行推广，因此活动页面的访问流量是非常巨大的；而采用静态页面的形式，不仅可以极大地提高页面加载速度（图片等静态资源可以通过CDN存储），而且可以极大地减轻流量对电商平台服务器端的压力（用户在浏览活动页面的时候并不会与电商平台进行任何交互）。至于点击链接进入电商平台的流量嘛，毕竟转换率总是存在的，转换以后的流量会小很多，而这部分流量才是真正有效的。</p>
<h2 id="如何对活动页面进行测试"><a href="#如何对活动页面进行测试" class="headerlink" title="如何对活动页面进行测试"></a>如何对活动页面进行测试</h2><p>那么，就这么简单的一个静态页面，还需要对它进行测试么？</p>
<p>咋一看，貌似还真没有可测试的内容，因为页面中就找不到一个真正意义上的功能点。</p>
<p>然而，历史经验表明，在软件工程中无论多简单的功能，都是有可能出现bug的。针对活动页面的形式，我们需要重点关注如下几点。</p>
<h3 id="1、商品信息一致性"><a href="#1、商品信息一致性" class="headerlink" title="1、商品信息一致性"></a>1、商品信息一致性</h3><p>促销活动页面中的商品信息都是由前端工程师写死的，而非从电商平台的数据库中读取后进行展示。因此，在实际操作中，活动页面上的信息，特别是价格数据，有可能和电商平台中的商品不一致，这个是我们在测试的时候需要重点关注的。</p>
<p>测试方式很简单，依次点击各个商品的链接，验证跳转的商品页面是否与促销活动页面中的商品信息一致即可。</p>
<h3 id="2、页面跳转行为一致性"><a href="#2、页面跳转行为一致性" class="headerlink" title="2、页面跳转行为一致性"></a>2、页面跳转行为一致性</h3><p>点击链接跳转页面，应该算是活动页面中唯一具有动作行为的功能了。而对于链接跳转而言，会存在两种形式，一种是在当前页面中加载商品页面，另一种是在新窗口中加载商品页面。</p>
<p>本来两种形式区别并不大，采用哪种形式都可以，但是从追求完美的角度出发，我们还是需要保证活动页面中的所有链接的跳转行为都是相同的。</p>
<p>因此，在测试时，逐一点击所有的链接，验证所有链接跳转行为是否一致即可。</p>
<h3 id="3、页面兼容性"><a href="#3、页面兼容性" class="headerlink" title="3、页面兼容性"></a>3、页面兼容性</h3><p>作为促销活动页面，虽然商品信息是最核心的内容，但是为了能吸引尽量多的用户，页面的设计往往花了很多功夫，力求精美。然而，用户访问活动页面的设备和浏览器五花八门，有可能是采用PC浏览器，有可能是采用iPhone设备，也可能是采用各种品牌和型号的Android设备，精心设计的活动页面在某些设备或浏览器上很有可能就出现样式混乱的情况。因此，促销活动页面的浏览器兼容性也是z在测试时需要重点关注的。</p>
<p>差异在哪儿呢？差异就是不同的浏览器内核，不同的设备操作系统，不同的屏幕分辨率。</p>
<p>当然，我们也不可能在所有类型的设备和浏览器上都测一遍，但是主流的浏览器内核和移动设备还是要尽量覆盖的。</p>
<p>推荐的测试方式如下：</p>
<ul>
<li>针对不同浏览器内核的测试，在电脑上采用Chrome、IE、Firefox、Safari浏览器分别加载活动页面；</li>
<li>针对不同移动设备类型的测试，在iPhone和Android设备上加载活动页面，iPhone和Android设备均只选一款即可；</li>
<li>针对不同屏幕分辨率的测试，可以在PC浏览器中打开开发者工具，里面可以模拟不同分辨率的设备加载页面，前面提到的浏览器基本都支持这个功能。</li>
</ul>
<h3 id="4、文案准确性"><a href="#4、文案准确性" class="headerlink" title="4、文案准确性"></a>4、文案准确性</h3><p>对于促销活动而言，吸引眼球的文案肯定是必不可少的，这也是在测试时需要重点关注的。</p>
<p>对于文案方面的测试，可以重点从以下几个方面进行考核。</p>
<p>首先，由于文案通常是由需求方提供，而活动页面是由设计师或前端工程师制作，因此有可能在制作页面的过程中出现了偏差，这个需要测试时仔细核对。</p>
<p>另外，文案中出现错别字的情况也比较多，这个也需要格外注意，尽量杜绝这样的低级错误。</p>
<p>还有一种情况，活动促销页面是面向某个国家的用户，语言可能是非汉语也非英语，这个时候周围谁也看不懂文案里面到底写的是啥。这个时候，只能请需求方再三进行确认，文案描述正确是一方面，另一方面就是需要考虑到目标国家的地域文化，不要出现产生歧义和误解的情况。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上内容便是从促销活动页面进行展开，联想到的关于测试的一些内容。</p>
<p>可以看出，即使是再简单的东西，也是需要进行测试的，而且测试需要考虑的因素也非常多。另一方面，这也说明测试并不应该仅仅局限于技术层面，只有当我们站在业务和质量保障的角度，才会有更开阔的视野。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章来说说促销活动页面测试的那些事儿。&lt;/p&gt;
&lt;h2 id=&quot;什么是促销活动页面？&quot;&gt;&lt;a href=&quot;#什么是促销活动页面？&quot; class=&quot;headerlink&quot; title=&quot;什么是促销活动页面？&quot;&gt;&lt;/a&gt;什么是促销活动页面？&lt;/h2&gt;&lt;p&gt;通常电商平台在节假
    
    </summary>
    
    
      <category term="promotion" scheme="http://debugtalk.com/tags/promotion/"/>
    
      <category term="H5" scheme="http://debugtalk.com/tags/H5/"/>
    
      <category term="test" scheme="http://debugtalk.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>敏捷团队协作：Confluence简易教程</title>
    <link href="http://debugtalk.com/post/confluence-simple-tutorial/"/>
    <id>http://debugtalk.com/post/confluence-simple-tutorial/</id>
    <published>2016-06-06T16:00:00.000Z</published>
    <updated>2016-07-23T07:26:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、Confluence简介"><a href="#0、Confluence简介" class="headerlink" title="0、Confluence简介"></a>0、Confluence简介</h2><p>Confluence是一个企业级的Wiki软件，可用于在企业、部门、团队内部进行信息共享和协同编辑。</p>
<h2 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h2><p>Confluence的使用并不复杂，只需掌握如下几个基础概念。</p>
<h3 id="空间（Space）"><a href="#空间（Space）" class="headerlink" title="空间（Space）"></a>空间（Space）</h3><p>空间是Confluence系统中的一个区域，用于存储wiki页面，并可实现对空间中的所有文档进行统一的权限管理。</p>
<p>通常，我们可以针对每个项目单独创建一个空间，然后将与该项目相关的文档信息放置到该空间中，并只对项目成员开设访问/编辑权限。</p>
<p>除了项目空间，每个成员都有一个个人空间。平时成员可以将工作总结或笔记等文档放置到自己的空间中；对于对团队有帮助的文档，就可以将文档移动至团队项目空间中。</p>
<h3 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h3><p>Dashboard是Confluence系统的主页，在Dashboard界面中包含了Confluence站点中的所有空间列表，以及最近更新内容的列表。</p>
<h3 id="页面（Page）"><a href="#页面（Page）" class="headerlink" title="页面（Page）"></a>页面（Page）</h3><p>在Confluence系统中，页面是存储和共享信息的主要方式。页面可以互相链接、连接、组织和访问，并以树状结构进行组织，放置于空间之中。</p>
<p>页面遵循所见即所得的编辑方式，操作上简单易用。更强大的地方在于，页面支持大量的内容展现形式，除了富文本文档外，还包括图表、视频、附件（可预览）、流程图、公式等等；如果还不够，还可以通过海量的第三方插件进行扩展。</p>
<p>在页面中可以通过<code>@</code>其它成员，通知相关成员查看文档。文档保存成功后，被<code>@</code>的成员就会收到邮件，并可根据邮件中的链接访问到该文档，然后进行评论或者协同编辑。</p>
<h3 id="模板（template）"><a href="#模板（template）" class="headerlink" title="模板（template）"></a>模板（template）</h3><p>创建页面时除了采用空白文档，也可以选择模板。模板是在空白文档的基础上，根据特定需求添加了一些文档要素，可辅助用户更好更快地创建文档。</p>
<p>Confluence内置了大量的模板，可辅助用于项目工作的各个环节，包括产品需求、会议记录、决策记录、指导手册（How-to）、回顾记录、工作计划、任务报告等等。并且由于Confluence和JIRA是同一家公司的产品，在Confluence中可以和JIRA进行无缝衔接，实现对产品质量实现更好的展现。</p>
<p>如果对Confluence自带的模板不满意，还可以对模板进行调整，或者根据自己的需求创建其它类型的模板。</p>
<h3 id="权限（Permission）"><a href="#权限（Permission）" class="headerlink" title="权限（Permission）"></a>权限（Permission）</h3><p>在安全性方面，Confluence具有完善和精细的权限控制，可以很好地控制用户在Wiki中创建、编辑内容和添加注释。</p>
<p>权限控制分3个维度，分别是团队（Group），个人（Individual Users），匿名用户（Anonymous）。</p>
<p>使用团队级的权限控制时，需要在Confluence服务器中对公司员工进行分组，好处在于配置比较方便，只需要对整个团队进行统一的权限配置。</p>
<p>但在实际项目中，经常会存在同一个项目包含多个跨团队成员的情况，这个时候就不适合采用团队权限配置方式，只能采用逐个添加成员的方式，并对各个成员分别配置权限。</p>
<p>另外一种情况，就是对于未登录的用户，以及项目成员以外的用户，可以开设部分权限，例如只读（View）。</p>
<h2 id="2、常见操作"><a href="#2、常见操作" class="headerlink" title="2、常见操作"></a>2、常见操作</h2><p>熟悉了Confluence的基础概念，基本上就可以摸索着对Confluence进行上手了。不过，为了减少摸索时间，在这里我再将Confluence中的常用操作进行说明。</p>
<h3 id="创建空间（Space）"><a href="#创建空间（Space）" class="headerlink" title="创建空间（Space）"></a>创建空间（Space）</h3><p>新建一个项目时，首先要做的就是创建一个空间，并进行初始化配置。</p>
<p>创建空间的方式很简单，可以从顶部菜单进行创建：【Spaces】-&gt;【Create Space】；也可以从Dashboard页面的Spaces页面中进行创建。</p>
<p><img src="/images/Confluence_Dashboard.png" alt=""></p>
<p>进入创建空间页面后，需要选择空间类型。这个需要根据空间的用途进行选择，对于团队协作的空间，推荐选择“Team Space”，如果实在不知道选择什么类型，选择“Blank Space”也是可以的。</p>
<p><img src="/images/Confluence_Create_Space.png" alt=""></p>
<p>然后是填写空间的基本信息。所有类型的空间都有两个必填字段，Space name和Space key。Space key可以理解为空间的ID，不同空间的Space key不能重复，但Space name是可以重复的。</p>
<p>另外，对于“Team Space”类型的空间，多了一个“Team members”字段，用于添加空间的成员。成员的名称是其公司邮箱的前缀。</p>
<p>需要说明的是，空间创建完成后，Space key字段是不能修改的，其它字段以及团队成员都可以进行修改。</p>
<p><img src="/images/Confluence_Create_Team_Space.png" alt=""></p>
<h3 id="配置空间权限"><a href="#配置空间权限" class="headerlink" title="配置空间权限"></a>配置空间权限</h3><p>创建空间后，根据项目需要，可以给空间设置权限。只有空间的管理员才能对空间权限进行配置。</p>
<p>操作方式如下：首先进入空间的页面，在空间左下角中，【Space tools】-&gt;【Permissions】，进入权限管理页面。</p>
<p><img src="/images/Confluence_Permissions_menu.png" alt=""></p>
<p>Confluence的权限控制比较完善，可以根据团队规范进行较为精细粒度的设置。</p>
<p><img src="/images/Confluence_Permissions_Setting.png" alt=""></p>
<h3 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h3><p>在Confluence中文件以树状结构进行组织。</p>
<p>推荐的创建方式是，先进入父目录的页面，然后再点击【Create】进行创建。在创建文档页面中，可以看到新建文档的“Parent”，表示新文档创建后将位于“Parent”文件的下一个层级中。</p>
<p><img src="/images/Confluence_Create_Page.png" alt=""></p>
<p>在新建文档时，需要选择文档模板。这个就根据文档的实际类型或用途进行选择即可，如果觉得都不合适，就选择“Blank page”。</p>
<h3 id="编写文档"><a href="#编写文档" class="headerlink" title="编写文档"></a>编写文档</h3><p>在编写文档时，页面遵循所见即所得的编辑方式，基本上跟在MS Word中的操作类似。</p>
<p>Confluence也集成了许多编辑工具，可以很方便地插入图表、链接、附件、代办列表等等。如果还不满足需求，可以点击【Insert】-&gt;【Other macros】，查找更多的扩展插件。</p>
<p><img src="/images/Confluence_Edit_Page.png" alt=""></p>
<p>例如，Confluence默认是不支持Markdown编辑模式的，如果想采用Markdown来编写文档，就可以通过上述方式到插件市场寻找Markdown的插件。</p>
<p>不过根据实践发现，当前Confluence的Markdown插件支持的还不够好，使用体验上不尽如人意。比较推荐的做法，还是在单独的Markdown编辑器上采用markdown语法进行编辑，编辑完成后进行预览，然后将渲染后的文档内容复制粘贴到Confluence中。</p>
<h3 id="移动文档"><a href="#移动文档" class="headerlink" title="移动文档"></a>移动文档</h3><p>很多时候我们需要调整目录结构，这就涉及到需要将文档移动到别的目录层级下。</p>
<p>操作方式如下：先进入到待移动的文档页面中，点击页面右上角的【…】-&gt;【Move】；</p>
<p><img src="/images/Confluence_Move_Page_menu.png" alt=""></p>
<p>然后选择新的目录即可。</p>
<p><img src="/images/Confluence_Move_Page.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0、Confluence简介&quot;&gt;&lt;a href=&quot;#0、Confluence简介&quot; class=&quot;headerlink&quot; title=&quot;0、Confluence简介&quot;&gt;&lt;/a&gt;0、Confluence简介&lt;/h2&gt;&lt;p&gt;Confluence是一个企业级的Wiki软
    
    </summary>
    
    
      <category term="Confluence" scheme="http://debugtalk.com/tags/Confluence/"/>
    
      <category term="敏捷团队" scheme="http://debugtalk.com/tags/%E6%95%8F%E6%8D%B7%E5%9B%A2%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>从0到1搭建移动App功能自动化测试平台（3）：编写iOS自动化测试脚本</title>
    <link href="http://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-write-iOS-testcase-scripts/"/>
    <id>http://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-write-iOS-testcase-scripts/</id>
    <published>2016-05-29T16:00:00.000Z</published>
    <updated>2016-07-23T07:59:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过前面三篇文章，我们已经将iOS自动化功能测试的开发环境全部准备就绪，也学习了iOS UI控件交互操作的一般性方法，接下来，就可以开始编写自动化测试脚本了。</p>
<p>在本文中，我将在M项目中挑选一个功能点，对其编写自动化测试脚本，演示编写自动化测试用例的整个流程。</p>
<h2 id="语言的选择：Python-or-Ruby？"><a href="#语言的选择：Python-or-Ruby？" class="headerlink" title="语言的选择：Python or Ruby？"></a>语言的选择：Python or Ruby？</h2><p>之前介绍Appium的时候也提到，Appium采用Client-Server的架构设计，并采用标准的HTTP通信协议；Client端基本上可以采用任意主流编程语言编写测试用例，包括但不限于C#、Ruby、Objective-C、Java、node.js、Python、PHP。</p>
<p>因此，在开始编写自动化测试脚本之前，首先需要选定一门编程语言。</p>
<p>这个选择因人而异，并不涉及到太大的优劣之分，基本上在上述几门语言中选择自己最熟悉的就好。</p>
<p>但对我而言，选择却没有那么干脆，前段时间在Python和Ruby之间犹豫了很久，经过艰难的决定，最终选择了Ruby。为什么不考虑Java？不熟是一方面，另一方面是觉得采用编译型语言写测试用例总感觉太重，这活儿还是解释型语言来做更合适些。</p>
<p>其实，最开始本来是想选择Python的，因为Python在软件测试领域比Ruby应用得更广，至少在国内，不管是公司团队，还是测试人员群体，使用Python的会比使用Ruby的多很多。</p>
<p>那为什么还是选择了Ruby呢？</p>
<p>我主要是基于如下几点考虑的：</p>
<ul>
<li>从Appium的官方文档来看，Appium对Ruby的支持力度，或者说是偏爱程度，貌似会更大些；在<a href="http://appium.io/downloads.html" target="_blank" rel="external">Appium Client Libraries</a>列表中将Ruby排在第一位就不说了，在<a href="http://appium.io/tutorial.html?lang=en" target="_blank" rel="external">Appium Tutorials</a>中示例语言就只采用了Ruby和Java进行描述。</li>
<li><a href="https://github.com/appium/ruby_lib" target="_blank" rel="external">Appium_Console</a>是采用Ruby编写的，在Console中执行的命令基本上可直接用在Ruby脚本中。</li>
<li>后续打算引入BDD（行为驱动开发）的测试模式，而不管是cucumber还是RSpec，都是采用Ruby开发的。</li>
</ul>
<p>当然，还有最最重要的一点，身处于珠江三角洲最大的Ruby阵营，周围Ruby大牛云集，公司的好多业务系统也都是采用Rails作为后台语言，完全没理由不选择Ruby啊。</p>
<h2 id="第一个测试用例：系统登录"><a href="#第一个测试用例：系统登录" class="headerlink" title="第一个测试用例：系统登录"></a>第一个测试用例：系统登录</h2><p>在测试领域中，系统登录这个功能点的地位，堪比软件开发中的<code>Hello World</code>，因此第一个测试用例就毫无悬念地选择系统登录了。</p>
<p>在编写自动化测试脚本之前，我们首先需要清楚用例执行的路径，路径中操作涉及到的控件，以及被操作控件的属性信息。</p>
<p>对于本次演示的APP来说，登录时需要先进入【My Account】页面，然后点击【Login】进入登录页面，接着在登录页面中输入账号密码后再点击【Login】按钮，完成登录操作。</p>
<p><img src="/images/DJI_Plus_Login.jpg" alt=""></p>
<p>确定了操作路径以后，就可以在<code>Appium Ruby Console</code>中依次操作一遍，目的是确保代码能正确地对控件进行操作。</p>
<p>第一步要点击【My Account】按钮，因此先查看下Button控件属性。要是不确定目标控件的类型，可以直接执行<code>page</code>命令，然后在返回结果中根据控件名称进行查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[1] pry(main)&gt; page :button</div><div class="line">...（略）</div><div class="line">UIAButton</div><div class="line">   name, label: My Account</div><div class="line">   id: My Account =&gt; My Account</div><div class="line">nil</div></pre></td></tr></table></figure>
<p>通过返回结果，可以看到【My Account】按钮的name、label属性就是“My Account”，因此可以通过<code>button_exact(&#39;My Account&#39;)</code>方式来定位控件，并进行点击操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[2] pry(main)&gt; button_exact(&apos;My Account&apos;).click</div><div class="line">nil</div></pre></td></tr></table></figure>
<p>执行命令后，观察iOS模拟器中APP的响应情况，看是否成功进入“My Account”页面。</p>
<p>第二步也是类似的，操作代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[3] pry(main)&gt; button_exact(&apos;Login&apos;).click</div><div class="line">nil</div></pre></td></tr></table></figure>
<p>进入到登录页面后，再次查看页面中的控件信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[4] pry(main)&gt; page</div><div class="line">...（略）</div><div class="line">UIATextField</div><div class="line">   value: Email Address</div><div class="line">   id: Email Address =&gt; Email Address</div><div class="line">UIASecureTextField</div><div class="line">   value: Password (6-16 characters)</div><div class="line">   id: Password (6-16 characters) =&gt; Password (6-16 characters)</div><div class="line">UIAButton</div><div class="line">   name, label: Login</div><div class="line">   id: Log In =&gt; Login</div><div class="line">       登录     =&gt; Login</div><div class="line">...（略）</div></pre></td></tr></table></figure>
<p>第三步需要填写账号密码，账号密码的控件属性分别是<code>UIATextField</code>和<code>UIASecureTextField</code>。由于这两个控件的类型在登录页面都是唯一的，因此可以采用控件的类型来进行定位，然后进行输入操作，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[5] pry(main)&gt; tag(&apos;UIATextField&apos;).type &apos;leo.lee@dji.com&apos;</div><div class="line">&quot;&quot;</div><div class="line">[6] pry(main)&gt; tag(&apos;UIASecureTextField&apos;).type &apos;123456&apos;</div><div class="line">&quot;&quot;</div></pre></td></tr></table></figure>
<p>执行完输入命令后，在iOS模拟器中可以看到账号密码输入框都成功输入了内容。</p>
<p>最后第四步点击【Login】按钮，操作上和第二步完全一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[7] pry(main)&gt; button_exact(&apos;Login&apos;).click</div><div class="line">nil</div></pre></td></tr></table></figure>
<p>执行完以上四个步骤后，在iOS模拟器中看到成功完成账号登录操作，这说明我们的执行命令没有问题，可以用于编写自动化测试代码。整合起来，测试脚本就是下面这样。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">button_exact(<span class="string">'My Account'</span>).click</div><div class="line">button_exact(<span class="string">'Login'</span>).click</div><div class="line">tag(<span class="string">'UIATextField'</span>).type <span class="string">'leo.lee@dji.com'</span></div><div class="line">tag(<span class="string">'UIASecureTextField'</span>).type <span class="string">'12345678'</span></div><div class="line">button_exact(<span class="string">'Login'</span>).click</div></pre></td></tr></table></figure>
<p>将以上脚本保存为<code>login.rb</code>文件。</p>
<p>但当我们直接运行<code>login.rb</code>文件时，并不能运行成功。原因很简单，脚本中的<code>button_exact</code>、<code>tag</code>这些方法并没有定义，我们在文件中也没有引入相关库文件。</p>
<p>在上一篇文章中有介绍过，通过<code>arc</code>启动虚拟机时，会从<code>appium.txt</code>中读取虚拟机的配置信息。类似的，我们在脚本中执行自动化测试时，也会加载虚拟机，因此同样需要在脚本中指定虚拟机的配置信息，并初始化<code>Appium Driver</code>的实例。</p>
<p>初始化代码可以通过<code>Appium Inspector</code>生成，基本上为固定模式，我们暂时不用深究。</p>
<p>添加初始化部分的代码后，测试脚本如下所示。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">require</span> <span class="string">'rubygems'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'appium_lib'</span></div><div class="line"></div><div class="line">capabilities = &#123;</div><div class="line">true<span class="string">'appium-version'</span> =&gt; <span class="string">'1.0'</span>,</div><div class="line">true<span class="string">'platformName'</span> =&gt; <span class="string">'iOS'</span>,</div><div class="line">true<span class="string">'platformVersion'</span> =&gt; <span class="string">'9.3'</span>,</div><div class="line">&#125;</div><div class="line">server_url = <span class="string">"http://0.0.0.0:4723/wd/hub"</span></div><div class="line">Appium::Driver.new(<span class="symbol">caps:</span> capabilities).start_driver</div><div class="line">Appium.promote_appium_methods Object</div><div class="line"></div><div class="line"><span class="comment"># testcase: login</span></div><div class="line">button_exact(<span class="string">'My Account'</span>).click</div><div class="line">button_exact(<span class="string">'Login'</span>).click</div><div class="line">tag(<span class="string">'UIATextField'</span>).type <span class="string">'leo.lee@dji.com'</span></div><div class="line">tag(<span class="string">'UIASecureTextField'</span>).type <span class="string">'123456'</span></div><div class="line">button_exact(<span class="string">'Login'</span>).click</div><div class="line"></div><div class="line">driver_quit</div></pre></td></tr></table></figure>
<h2 id="优化测试脚本：加入等待机制"><a href="#优化测试脚本：加入等待机制" class="headerlink" title="优化测试脚本：加入等待机制"></a>优化测试脚本：加入等待机制</h2><p>如上测试脚本编写好后，在Terminal中运行<code>ruby login.rb</code>，就可以执行脚本了。</p>
<p>运行命令后，会看到iOS虚拟机成功启动，接着App成功进行加载，然后自动按照前面设计的路径，执行系统登录流程。</p>
<p>但是，在实际操作过程中，发现有时候运行脚本时会出现找不到控件的异常，异常信息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">➜ ruby login.rb</div><div class="line">/Library/Ruby/Gems/2.0.0/gems/appium_lib-8.0.2/lib/appium_lib/common/helper.rb:218:in `_no_such_element&apos;: An element could not be located on the page using the given search parameters. (Selenium::WebDriver::Error::NoSuchElementError)</div><div class="line">truefrom /Library/Ruby/Gems/2.0.0/gems/appium_lib-8.0.2/lib/appium_lib/ios/helper.rb:578:in `ele_by_json&apos;</div><div class="line">truefrom /Library/Ruby/Gems/2.0.0/gems/appium_lib-8.0.2/lib/appium_lib/ios/helper.rb:367:in `ele_by_json_visible_exact&apos;</div><div class="line">truefrom /Library/Ruby/Gems/2.0.0/gems/appium_lib-8.0.2/lib/appium_lib/ios/element/button.rb:41:in `button_exact&apos;</div><div class="line">truefrom /Library/Ruby/Gems/2.0.0/gems/appium_lib-8.0.2/lib/appium_lib/driver.rb:226:in `rescue in block (4 levels) in promote_appium_methods&apos;</div><div class="line">truefrom /Library/Ruby/Gems/2.0.0/gems/appium_lib-8.0.2/lib/appium_lib/driver.rb:217:in `block (4 levels) in promote_appium_methods&apos;</div><div class="line">truefrom login.rb:28:in `&lt;main&gt;&apos;</div></pre></td></tr></table></figure>
<p>更奇怪的是，这个异常并不是稳定出现的，有时候能正常运行整个用例，但有时在某个步骤就会抛出找不到控件的异常。这是什么原因呢？为什么在<code>Appium Ruby Console</code>中单步操作时就不会出现这个问题，但是在执行脚本的时候就会偶尔出现异常呢？</p>
<p>原来，在我们之前的脚本中，两条命令之间并没有间隔时间，有可能前一条命令执行完后，模拟器中的应用还没有完成下一个页面的加载，下一条命令就又开始查找控件，然后由于找不到控件就抛出异常了。</p>
<p>这也是为什么我们在<code>Appium Ruby Console</code>中没有出现这样的问题。因为手工输入命令多少会有一些耗时，输入两条命令的间隔时间足够虚拟机中的APP完成下一页面的加载了。</p>
<p>那针对这种情况，我们要怎么修改测试脚本呢？难道要在每一行代码之间都添加休眠（sleep）函数么？</p>
<p>也不用这么麻烦，针对这类情况，<code>ruby_lib</code>实现了<code>wait</code>机制。将执行命令放入到<code>wait{}</code>中后，执行脚本时就会等待该命令执行完成后再去执行下一条命令。当然，等待也不是无休止的，如果等待30秒后还是没有执行完，仍然会抛出异常。</p>
<p>登录流程的测试脚本修改后如下所示（已省略初始化部分的代码）：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wait &#123; button_exact(<span class="string">'My Account'</span>).click &#125;</div><div class="line">wait &#123; button_exact(<span class="string">'Login'</span>).click &#125;</div><div class="line">wait &#123; tag(<span class="string">'UIATextField'</span>).type <span class="string">'leo.lee@dji.com'</span> &#125;</div><div class="line">wait &#123; tag(<span class="string">'UIASecureTextField'</span>).type <span class="string">'123456'</span> &#125;</div><div class="line">wait &#123; button_exact(<span class="string">'Login'</span>).click &#125;</div></pre></td></tr></table></figure>
<p>对脚本添加<code>wait</code>机制后，之前出现的找不到控件的异常就不再出现了。</p>
<h2 id="优化测试脚本：加入结果检测机制"><a href="#优化测试脚本：加入结果检测机制" class="headerlink" title="优化测试脚本：加入结果检测机制"></a>优化测试脚本：加入结果检测机制</h2><p>然而，现在脚本仍然不够完善。</p>
<p>我们在<code>Appium Ruby Console</code>中手工执行命令后，都是由人工肉眼确认虚拟机中APP是否成功进入下一个页面，或者返回结果是否正确。</p>
<p>但是在执行自动化测试脚本时，我们不可能一直去盯着模拟器。因此，我们还需要在脚本中加入结果检测机制，通过脚本实现结果正确性的检测。</p>
<p>具体怎么做呢？</p>
<p>原理也很简单，只需要在下一个页面中，寻找一个在前一个页面中没有的控件。</p>
<p>例如，由A页面跳转至B页面，在B页面中会存在“Welcome”的文本控件，但是在A页面中是没有这个“Welcome”文本控件的；那么，我们就可以在脚本中的跳转页面语句之后，加入一条检测“Welcome”文本控件的语句；后续在执行测试脚本的时候，如果页面跳转失败，就会因为找不到控件而抛出异常，我们也能通过这个异常知道测试执行失败了。</p>
<p>当然，对下一页面中的控件进行检测时同样需要加入等待机制的。</p>
<p>登录流程的测试脚本修改后如下所示（已省略初始化部分的代码）：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">wait &#123; button_exact(<span class="string">'My Account'</span>).click &#125;</div><div class="line">wait &#123; text_exact <span class="string">'System Settings'</span> &#125;</div><div class="line"></div><div class="line">wait &#123; button_exact(<span class="string">'Login'</span>).click &#125;</div><div class="line">wait &#123; button_exact <span class="string">'Forget password?'</span> &#125;</div><div class="line"></div><div class="line">wait &#123; tag(<span class="string">'UIATextField'</span>).type <span class="string">'leo.lee@dji.com'</span> &#125;</div><div class="line">wait &#123; tag(<span class="string">'UIASecureTextField'</span>).type <span class="string">'12345678'</span> &#125;</div><div class="line">wait &#123; button_exact(<span class="string">'Login'</span>).click &#125;</div><div class="line">wait &#123; text_exact <span class="string">'My Message'</span> &#125;</div></pre></td></tr></table></figure>
<p>至此，系统登录流程的自动化测试脚本我们就编写完成了。</p>
<h2 id="To-be-continued-…"><a href="#To-be-continued-…" class="headerlink" title="To be continued …"></a>To be continued …</h2><p>在本文中，我们通过系统登录这一典型功能点，演示了编写自动化测试用例的整个流程。</p>
<p>在下一篇文章中，我们还会对自动化测试脚本的结构进行进一步优化，并实现测试代码工程化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过前面三篇文章，我们已经将iOS自动化功能测试的开发环境全部准备就绪，也学习了iOS UI控件交互操作的一般性方法，接下来，就可以开始编写自动化测试脚本了。&lt;/p&gt;
&lt;p&gt;在本文中，我将在M项目中挑选一个功能点，对其编写自动化测试脚本，演示编写自动化测试用例的整个流程。&lt;
    
    </summary>
    
    
      <category term="Python" scheme="http://debugtalk.com/tags/Python/"/>
    
      <category term="AutomationTest" scheme="http://debugtalk.com/tags/AutomationTest/"/>
    
      <category term="Appium" scheme="http://debugtalk.com/tags/Appium/"/>
    
      <category term="F0T1" scheme="http://debugtalk.com/tags/F0T1/"/>
    
      <category term="iOS" scheme="http://debugtalk.com/tags/iOS/"/>
    
      <category term="Ruby" scheme="http://debugtalk.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>从0到1搭建移动App功能自动化测试平台（2）：操作iOS应用的控件</title>
    <link href="http://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-Appium-interrogate-iOS-UI/"/>
    <id>http://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-Appium-interrogate-iOS-UI/</id>
    <published>2016-05-28T16:00:00.000Z</published>
    <updated>2016-07-23T07:58:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>前两天微信突然发来一条系统消息，提示<code>DebugTalk</code>可以开通原创标识了（同时也有了评论功能），虽然一直在期待，但没想到来得这么快，着实是个不小的惊喜。</p>
<p>另外，最近在公众号后台也收到好几个朋友的信息，有的是询问某某部分什么时候能发布，有的是希望能加快更新速度。说实话，收到这样的信息虽然会有压力，但真的挺开心的，因为这说明<code>DebugTalk</code>至少能给一部分人带去价值，这说明这件事本身还是值得坚持去做的。</p>
<p>不过，在更新频率这件事儿上，的确是要跟大家说抱歉了。因为<code>DebugTalk</code>发布的内容全都是原创，主题基本上都是来源于我日常测试工作的经验积累，或者我近期学习一些测试技术的收获总结，这也意味着，我写的东西很多时候并不是自己完全熟悉的（完全掌握的东西也没有足够的动力专门花时间去写）。</p>
<p>就拿最近连载的《从0到1搭建移动App功能自动化测试平台》系列来说，由于我也是边探索边总结，因此中途难免会遇到一些意想不到的坑，造成额外的耗时，而且为了保证文章能尽量通俗易通，我也需要对涉及到的内容充分进行理解，并且经过大量实践进行验证，然后才能站在半个初学者、半个过来人的角度，重新整理思路，最后以尽可能流畅的思路将主题内容讲解清楚。</p>
<p>基于这些原因，<code>DebugTalk</code>要做到每日更新是很难了，但是保证每周发布1~2篇还是可以的，希望大家能理解。</p>
<h2 id="关于UI控件"><a href="#关于UI控件" class="headerlink" title="关于UI控件"></a>关于UI控件</h2><p>在上一篇文章中，我们成功地通过Appium Inspector调用模拟器并运行iOS应用，iOS的自动化测试环境也已全部准备就绪了。</p>
<p>那么接下来，我们就可以开始实现自动化测试了么？</p>
<p>貌似还不行。在开始之前，我们先想下什么是APP功能自动化测试。</p>
<p>APP的功能自动化测试，简单地来说，就是让功能测试用例自动地在APP上执行。具体到每一个测试用例，就是能模拟用户行为对UI控件进行操作，自动化地实现一个功能点或者一个流程的操作。再细分到每一步，就是对UI控件进行操作。</p>
<p>因此，在正式开始编写自动化测试用例之前，我们还需要熟悉如何与APP的UI控件进行交互操作。</p>
<p>在iOS系统中，UI控件有多种类型，常见的有按钮（UIAButton）、文本（UIAStaticText）、输入框（UIATextField）等等。但不管是对什么类型的UI控件进行操作，基本都可以分解为三步，首先是获取目标控件的属性信息，然后是对目标控件进行定位，最后是对定位到的控件执行动作。</p>
<h2 id="获取UI控件信息"><a href="#获取UI控件信息" class="headerlink" title="获取UI控件信息"></a>获取UI控件信息</h2><p>在Appium中，要获取iOS的UI控件元素信息，可以采用两种方式：一种是在前一篇文章中提到的Appium Inspector，另一种是借助Ruby实现的<code>appium_console</code>，在Terminal中通过命令进行查询。</p>
<h3 id="Appium-Inspector"><a href="#Appium-Inspector" class="headerlink" title="Appium Inspector"></a>Appium Inspector</h3><p>运行Appium Server，并启动【Inspector】后，整体界面如下图所示。</p>
<p><img src="/images/Appium_inspector_introduction.jpg" alt=""></p>
<p>现对照着这张图对Appium Inspector进行介绍。</p>
<p>在右边部分，是启动的模拟器，里面运行着我们的待测APP。我们可以像在真机中一样，在模拟器中执行任意功能的操作，当然，模拟器跟真机毕竟还是有区别的，跟传感器相关的功能，例如摄像头、重力感应等，是没法实现的。</p>
<p>在左边部分，就是<code>Appium Inspector</code>。Inspector主要由如下四个部分组成：</p>
<ul>
<li>预览界面区：显示画面与模拟器界面一致；不过，当我们在模拟器中切换界面后，Inspector的预览区中显示图像并不会自动同步，若要同步，需要点击【Refresh】按钮，然后Inspector会将模拟器当前UI信息dump后显示到预览区；在预览区中，可以点击选择任意UI控件。</li>
<li>UI信息展示区：展示当前界面预览区中所有UI元素的层级关系和UI元素的详细信息；在预览区中点击选择任意UI控件后，在“Details”信息框中展示选中控件的详细信息，包括name、label、value、xpath等属性值；通过层级关系，我们也能了解选中控件在当前界面树状结构中所处的具体位置。</li>
<li>交互操作区：模拟用户在设备上的操作，例如单击（tap）、滑动（swipe）、晃动（shake）、输入（input）等；操作动作是针对预览界面区选中的控件，因此在操作之前，务必需要先在预览区点击选择UI元素。</li>
<li>脚本生成区：将用户行为转换为脚本代码；点击【Record】按钮后，会弹出代码区域；在交互操作区进行操作后，就会实时生成对应的脚本代码；代码语言可通过下拉框进行选择，当前支持的语言类型有：C#、Ruby、Objective-C、Java、node.js、Python。</li>
</ul>
<p>在实践操作中，Inspector最大的用途就是在可以可视化地查看UI元素信息，并且可以将操作转换为脚本代码，这对初学者尤为有用。</p>
<p>例如，在预览区点击选中按钮“BUY NOW”，然后在UI信息展示区的Details窗口就可以看到该按钮的所有属性信息。在交互操作区点击【Tap】按钮后，就会模拟用户点击“BUY NOW”按钮，并且在脚本区域生成当次按钮点击的脚本（选择Ruby语言）：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find_element(<span class="symbol">:name</span>, <span class="string">"BUY NOW &gt;"</span>).click</div></pre></td></tr></table></figure>
<p>如上就是使用<code>Appium Inspector</code>的一般性流程。</p>
<h3 id="Appium-Ruby-Console"><a href="#Appium-Ruby-Console" class="headerlink" title="Appium Ruby Console"></a>Appium Ruby Console</h3><p>有了<code>Appium Inspector</code>，为什么还需要<code>Appium Ruby Console</code>呢？</p>
<p>其实，<code>Appium Ruby Console</code>也并不是必须的。经过与多个熟悉<code>Appium</code>的前辈交流，他们也从未用过<code>Appium Ruby Console</code>，这说明<code>Appium Ruby Console</code>并不是必须的，没有它也不会影响我们对<code>Appium</code>的使用。</p>
<p>但是，这并不意味着<code>Appium Ruby Console</code>是多余的。经过这些天对<code>Appium</code>的摸索，我越发地喜欢上<code>Appium Ruby Console</code>，并且使用的频率越来越高，现在已基本上很少使用<code>Appium Inspector</code>了。这种感觉怎么说呢？<code>Inspector</code>相比于<code>Ruby Conosle</code>，就像是<code>GUI</code>相比于<code>Linux Terminal</code>，大家应该能体会了吧。</p>
<p><code>Appium Inspector</code>的功能是很齐全，GUI操作也很方便，但是，最大的问题就是使用的时候非常慢，在预览界面区切换一个页面常常需要好几秒，甚至数十秒，这是很难让人接受的。</p>
<p>在上一节中也说到了，Inspector最大的用途就是在可以可视化地查看UI元素信息，并且可以将操作转换为脚本代码。但是当我们对<code>Appium</code>的常用API熟悉以后，我们就不再需要由工具来生成脚本，因为自己直接写会更快，前提是我们能知道目标控件的属性信息（type、name、label、value）。</p>
<p>在这种情况下，如果能有一种方式可以供我们快速查看当前屏幕的控件属性信息，那该有多好。</p>
<p>庆幸的是，在阅读<code>Appium</code>官方文档时，发现<code>Appium</code>的确是支持命令行方式的，这就是<code>Appium Ruby Console</code>。</p>
<p><code>Appium Ruby Console</code>是采用Ruby语言开发的，在使用方式上面和Ruby的<code>irb</code>很类似。</p>
<p>在使用<code>Appium Ruby Console</code>时，虚拟机的配置信息并不会从GUI中读取，而是要通过配置文件进行指定。</p>
<p>配置文件的名称统一要求为<code>appium.txt</code>，内容形式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[caps]</div><div class="line">platformName = &quot;ios&quot;</div><div class="line">platformVersion = &apos;9.3&apos;,</div><div class="line">app = &quot;/path/to/UICatalog.app.zip&quot;</div><div class="line">deviceName = &quot;iPhone Simulator&quot;</div></pre></td></tr></table></figure>
<p>其中，<code>platformName</code>指定虚拟机操作系统类型，“ios”或者”android”；<code>platformVersion</code>指定操作系统的版本，例如iOS的’9.3’，或者Android的’5.1’；<code>app</code>指定被测应用安装包的路径。这三个参数是必须的，与Inspector中的配置也能对应上。</p>
<p>在使用<code>Appium Ruby Console</code>时，首先需要启动<code>Appium Server</code>，通过<code>GUI</code>或者<code>Terminal</code>均可。</p>
<p>然后，在Terminal中，进入到<code>appium.txt</code>文件所在的目录，执行<code>arc</code>命令即可启动<code>Appium Ruby Console</code>。<code>arc</code>，即是appium ruby console首字母的组合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">➜ ls</div><div class="line">appium.txt</div><div class="line">➜ arc</div><div class="line">[1] pry(main)&gt;</div></pre></td></tr></table></figure>
<p>接下来，就可以通过执行命令查询当前设备屏幕中的控件信息。</p>
<p>使用频率最高的一个命令是<code>page</code>，通过这个命令可以查看到当前屏幕中所有控件的基本信息。</p>
<p>例如，当屏幕停留在前面截图中的页面时，执行<code>page</code>命令可以得到如下内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">[1] pry(main)&gt; page</div><div class="line">UIANavigationBar</div><div class="line">   name: HomeView</div><div class="line">   id: Home =&gt; Home</div><div class="line">       米    =&gt; m</div><div class="line">       去看看  =&gt; View</div><div class="line">UIAButton</div><div class="line">   name, label: tabbar category gray</div><div class="line">UIAImage</div><div class="line">   name: dji_logo.png</div><div class="line">UIAButton</div><div class="line">   name, label: tabbar cart gray</div><div class="line">UIATableView</div><div class="line">   value: rows 1 to 4 of 15</div><div class="line">UIAPageIndicator</div><div class="line">   value: page 2 of 2</div><div class="line">UIATableCell</div><div class="line">   name: For the first time ever in a hand held camera, the Osmo brings professional, realtime cinema-quality stabilization.</div><div class="line">   id: 米 =&gt; m</div><div class="line">UIAStaticText</div><div class="line">   name, label, value: For the first time ever in a hand held camera, the Osmo brings professional, realtime cinema-quality stabilization.</div><div class="line">   id: 米 =&gt; m</div><div class="line">UIAStaticText</div><div class="line">   name, label, value: OSMO</div><div class="line">UIAButton</div><div class="line">   name, label: SHOP NOW &gt;</div><div class="line">UIATableCell</div><div class="line">   name: Ronin</div><div class="line">UIAStaticText</div><div class="line">   name, label, value: Ronin</div><div class="line">UIAStaticText</div><div class="line">   name, label, value: Phantom</div><div class="line">   id: 米 =&gt; m</div><div class="line">... (略)</div><div class="line">UIAButton</div><div class="line">   name, label: Store</div><div class="line">   value: 1</div><div class="line">   id: 门店 =&gt; Store</div><div class="line">... (略)</div><div class="line">UIAButton</div><div class="line">   name, label: My Account</div><div class="line">   id: My Account =&gt; My Account</div><div class="line">nil</div></pre></td></tr></table></figure>
<p>通过返回信息，我们就可以看到所有控件的type、name、label、value属性值。如果在某个控件下没有显示label或value，这是因为这个值为空，我们可以不予理会。</p>
<p>由于<code>page</code>返回的信息太多，可能不便于查看，因此在使用<code>page</code>命令时，也可以指定控件的类型，相当于对当前屏幕的控件进行筛选，只返回指定类型的控件信息。</p>
<p>指定控件类型时，可以通过string类型进行指定（如 page “Image”），也可通过symbol类型进行指定（如 page :cell）。指定的类型可只填写部分内容，并且不分区大小写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[2] pry(main)&gt; page &quot;Image&quot;</div><div class="line">UIAImage</div><div class="line">   name: dji_logo.png</div><div class="line">nil</div><div class="line">[3] pry(main)&gt; page :cell</div><div class="line">UIATableCell</div><div class="line">   name: DJI’s smartest flying camera ever.</div><div class="line">   id: 米 =&gt; m</div><div class="line">UIATableCell</div><div class="line">   name: Ronin</div><div class="line">UIATableCell</div><div class="line">   name: Phantom</div><div class="line">   id: 米 =&gt; m</div><div class="line">nil</div></pre></td></tr></table></figure>
<p>如果需要查看当前屏幕的所有控件类型，可以执行<code>page_class</code>命令进行查看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[4] pry(main)&gt; page_class</div><div class="line">14x UIAButton</div><div class="line">8x UIAStaticText</div><div class="line">4x UIAElement</div><div class="line">4x UIATableCell</div><div class="line">2x UIAImage</div><div class="line">2x UIAWindow</div><div class="line">1x UIAPageIndicator</div><div class="line">1x UIATableView</div><div class="line">1x UIAStatusBar</div><div class="line">1x UIANavigationBar</div><div class="line">1x UIATabBar</div><div class="line">1x UIAApplication</div><div class="line">nil</div></pre></td></tr></table></figure>
<p>基本上，<code>page</code>返回的控件信息已经足够满足绝大多数场景需求，但有时候情况比较特殊，需要<code>enabled</code>、<code>xpath</code>、<code>visible</code>、坐标等属性信息，这时就可以通过执行<code>source</code>命令。执行<code>source</code>命令后，就可以返回当前屏幕中所有控件的所有信息，以xml格式进行展现。</p>
<h2 id="定位UI控件"><a href="#定位UI控件" class="headerlink" title="定位UI控件"></a>定位UI控件</h2><p>获取到UI控件的属性信息后，就可以对控件进行定位了。</p>
<p>首先介绍下最通用的定位方式，<code>find</code>。通过<code>find</code>命令，可以实现在控件的诸多属性值（<code>name</code>、<code>label</code>、<code>value</code>、<code>hint</code>）中查找目标值。查询时不区分大小写，如果匹配结果有多个，则只返回第一个结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[5] pry(main)&gt; find(&apos;osmo&apos;)</div><div class="line">#&lt;Selenium::WebDriver::Element:0x..febd52a30dcdfea32 id=&quot;2&quot;&gt;</div><div class="line">[6] pry(main)&gt; find(&apos;osmo&apos;).label</div><div class="line">&quot;Osmo&quot;</div></pre></td></tr></table></figure>
<p>另一个通用的定位方式是<code>find_element</code>，它也可以实现对所有控件进行查找，但是相对于<code>find</code>，可以对属性类型进行指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[7] pry(main)&gt; find_element(:class_name, &apos;UIATextField&apos;)</div><div class="line">#&lt;Selenium::WebDriver::Element:0x31d87e3848df8804 id=&quot;3&quot;&gt;</div><div class="line">[8] pry(main)&gt; find_element(:class_name, &apos;UIATextField&apos;).value</div><div class="line">&quot;Email Address&quot;</div></pre></td></tr></table></figure>
<p>不过在实践中发现，采用<code>find</code>、<code>find_element</code>这类通用的定位方式并不好用，因为定位结果经常不是我们期望的。</p>
<p>经过反复摸索，我推荐根据目标控件的类型，选择对应的定位方式。总结起来，主要有以下三种方式。</p>
<p>针对Button类型的控件（UIAButton），采用<code>button_exact</code>进行定位：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[9] pry(main)&gt; button_exact(&apos;Login&apos;)</div><div class="line">#&lt;Selenium::WebDriver::Element:0x..feaebd8302b6d77cc id=&quot;4&quot;&gt;</div></pre></td></tr></table></figure>
<p>针对Text类型的控件（UIAStaticText），采用<code>text_exact</code>进行定位：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[10] pry(main)&gt; text_exact(&apos;Phantom&apos;)</div><div class="line">#&lt;Selenium::WebDriver::Element:0x1347e89100fdcee2 id=&quot;5&quot;&gt;</div></pre></td></tr></table></figure>
<p>针对控件类型进行定位时，采用<code>tag</code>；如下方式等价于<code>find_element(:class_name, &#39;UIASecureTextField&#39;)</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[11] pry(main)&gt; tag(&apos;UIASecureTextField&apos;)</div><div class="line">#&lt;Selenium::WebDriver::Element:0x..fc6f5efd05a82cdca id=&quot;6&quot;&gt;</div></pre></td></tr></table></figure>
<p>基本上，这三种方式就已经足够应付绝大多数测试场景了。当然，这三种方式只是我个人经过实践后选择的定位方式，除了这三种，<code>Appium</code>还支持很多种其它定位方式，大家可自行查看<code>Appium</code>官方文档进行选择。</p>
<p>另外，除了对控件进行定位，有时候我们还想判断当前屏幕中是否存在某个控件（通常用于结果检测判断），这要怎么做呢？</p>
<p>一种方式是借助于<code>Appium</code>的控件查找机制，即找不到控件时会抛出异常（<code>Selenium::WebDriver::Error::NoSuchElementError</code>）；反过来，当查找某个控件抛出异常时，则说明当前屏幕中不存在该控件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[12] pry(main)&gt; button_exact(&apos;Login_invalid&apos;)</div><div class="line">Selenium::WebDriver::Error::NoSuchElementError: An element could not be located on the page using the given search parameters.</div><div class="line">from /Library/Ruby/Gems/2.0.0/gems/appium_lib-8.0.2/lib/appium_lib/common/helper.rb:218:in `_no_such_element&apos;</div></pre></td></tr></table></figure>
<p>该种方式可行，但比较暴力，基本上不会采用这种方式。</p>
<p>另一种更好的方式是，查找当前屏幕中指定控件的个数，若个数不为零，则说明控件存在。具体操作上，将<code>button_exact</code>替换为<code>buttons_exact</code>，将<code>text_exact</code>替换为<code>texts_exact</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[12] pry(main)&gt; buttons_exact(&apos;Login&apos;).count</div><div class="line">1</div><div class="line">[13] pry(main)&gt; buttons_exact(&apos;Login_invalid&apos;).count</div><div class="line">0</div></pre></td></tr></table></figure>
<p>除此之外，基于Ruby实现的<code>appium_lib</code>还支持<code>exists</code>方法，可直接返回Boolean值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[14] pry(main)&gt; exists &#123; button_exact(&apos;Login&apos;) &#125;</div><div class="line">true</div><div class="line">[15] pry(main)&gt; exists &#123; button_exact(&apos;Login_invalid&apos;) &#125;</div><div class="line">false</div></pre></td></tr></table></figure>
<h2 id="对控件执行操作"><a href="#对控件执行操作" class="headerlink" title="对控件执行操作"></a>对控件执行操作</h2><p>定位到具体的控件后，操作就比较容易了。</p>
<p>操作类型不多，最常用就是点击（click）和输入（type），这两个操作能覆盖80%以上的场景。</p>
<p>对于点击操作，才定位到的控件后面添加<code>.click</code>方法；对于输入操作，在定位到的输入框控件后面添加<code>.type</code>方法，并传入输入值。</p>
<p>例如，账号登录操作就包含输入和点击两种操作类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[16] pry(main)&gt; find_element(:class_name, &apos;UIATextField&apos;).type &apos;leo.lee@dji.com&apos;</div><div class="line">&quot;&quot;</div><div class="line">[17] pry(main)&gt; find_element(:class_name, &apos;UIASecureTextField&apos;).type &apos;123456&apos;</div><div class="line">&quot;&quot;</div><div class="line">[18] pry(main)&gt; button_exact(&apos;Login&apos;).click</div><div class="line">nil</div></pre></td></tr></table></figure>
<h2 id="To-be-continued-…"><a href="#To-be-continued-…" class="headerlink" title="To be continued …"></a>To be continued …</h2><p>在本文中，我们学习了对iOS UI控件进行交互操作的一般性方法，为编写自动化测试脚本打好了基础。</p>
<p>在下一篇文章中，我们就要正式开始针对iOS应用编写自动化测试脚本了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;前两天微信突然发来一条系统消息，提示&lt;code&gt;DebugTalk&lt;/code&gt;可以开通原创标识了（同时也有了评论功能），虽
    
    </summary>
    
    
      <category term="AutomationTest" scheme="http://debugtalk.com/tags/AutomationTest/"/>
    
      <category term="Appium" scheme="http://debugtalk.com/tags/Appium/"/>
    
      <category term="F0T1" scheme="http://debugtalk.com/tags/F0T1/"/>
    
      <category term="iOS" scheme="http://debugtalk.com/tags/iOS/"/>
    
      <category term="Simulator" scheme="http://debugtalk.com/tags/Simulator/"/>
    
      <category term="Ruby" scheme="http://debugtalk.com/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>从0到1搭建移动App功能自动化测试平台（1）：模拟器中运行iOS应用</title>
    <link href="http://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-Appium-inspector-iOS-simulator/"/>
    <id>http://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-Appium-inspector-iOS-simulator/</id>
    <published>2016-05-20T16:00:00.000Z</published>
    <updated>2016-07-23T07:58:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中，我对本系列教程的项目背景进行了介绍，并对自动化测试平台的建设进行了规划。</p>
<p>在本文中，我将在已准备就绪的iOS自动化测试环境的基础上，通过Appium调用模拟器运行iOS应用。内容很是基础，熟悉的同学可直接略过。</p>
<h2 id="iOS应用安装包的基础知识"><a href="#iOS应用安装包的基础知识" class="headerlink" title="iOS应用安装包的基础知识"></a>iOS应用安装包的基础知识</h2><p>作为完全的iOS新手，困惑的第一个问题就是iOS安装包文件。</p>
<p>在Android系统中，安装App的途径很多，除了各类应用市场，普通用户也经常直接下载apk安装包文件后手动进行安装，因此大家对Android的安装包文件都比较熟悉。</p>
<p>但是对于iOS系统就不一样了，由于我们普通用户在iOS上安装应用的时候基本上只能通过Apple Store进行安装（未越狱），没有机会接触原始的安装包文件，因此往往连iOS应用的安装包到底是什么格式后缀都不清楚。</p>
<p>现在我们想在Appium App中通过模拟器运行被测应用，需要指定iOS app的安装包路径，因此需要首先获得一个iOS app安装包。</p>
<p><img src="/images/Appium_iOS_Settings_init.jpg" alt=""></p>
<p>那么iOS app的安装包长啥样呢？</p>
<p>或者在这个问题之前，我们先来看下另一个问题：对于iOS设备来说，如果不通过Apple Store，我们可以怎样安装一个应用？</p>
<p>针对这个问题，我搜了些资料，也请教了周围的同事，了解到的途径有如下几个：</p>
<ul>
<li>企业证书：该种方式适用于企业内部；通过企业证书编译出的iOS应用，无需上传至Apple Store，即可无限制的安装到企业员工的iOS设备中。只是需要解决的一个问题是，由于iOS设备没有文件管理器，没法将安装包拷贝到iOS设备中，因此常用的做法是将安装包（<code>.ipa</code>文件）上传至一些下载服务器（例如<code>fir.im</code>），并生成二维码，然后用户扫描二维码后即可通过浏览器下载安装包并进行安装。由此联想到另外一个方法，通过微信文件传输助手将安装包（<code>.ipa</code>）传输至iOS设备，然后再进行安装应该也是可以的吧？这种方法不知在原理上是否可行，因为在试验时由于安装包大于30M，微信无法传输，所以没能进行验证。</li>
<li>Xcode：该种方式适用于iOS开发者；开发者在Xcode中连上iOS设备对源码进行编译，编译生成的应用会自动安装至iOS设备。当然，该种方式也是需要iOS开发者证书。</li>
<li>PP助手：该种方式适用于普通用户；PP助手是一个非苹果官方的设备资源管理工具，可以实现对未越狱的iOS设备进行应用管理，也可以安装本地<code>.ipa</code>文件，前提是<code>.ipa</code>文件具有合适的签名。</li>
</ul>
<p>在上面列举的安装应用的途径中，反复提到了<code>.ipa</code>文件，那<code>.ipa</code>应该就是iOS应用程序的后缀了吧？暂且这么认为吧。</p>
<p>再回到前面的场景，要在iOS模拟器中运行iOS应用，我们是否可以找研发人员要一个<code>.ipa</code>安装包文件，然后就能在模拟器中加载运行应用呢？</p>
<p>刚开始的时候我是这么认为的。于是我获取到<code>.ipa</code>文件后，在<code>App Path</code>中填写该文件的路径，然后启动Appium Server；接着我再打开Inspector时，发现iOS模拟器启动了，但是在应用启动的时候就出问题了，始终无法正常启动，感觉像是启动崩溃，反复尝试多次仍然如此。</p>
<p>再次经过Google，总算是明白出现问题的原因了，总结下来有如下几点：</p>
<ul>
<li>不管是从Apple Store或iTunes上下载的应用，还是在Xcode中针对真机设备编译生成的<code>.ipa</code>文件，都是面向于ARM处理器的iOS设备，只能在真机设备中进行安装；</li>
<li>而在Mac OSX系统中运行的iOS模拟器，运行环境是基于Intel处理器的；</li>
<li>因此，若是针对真机设备编译生成的<code>.ipa</code>文件，是无法在iOS模拟器中正常运行的，毕竟处理器架构都不一样；</li>
<li>要想在iOS模拟器中运行应用，则必须在Xcode中编译时选择模拟器类型；编译生成的文件后缀为<code>.app</code>。</li>
</ul>
<h2 id="准备-app文件"><a href="#准备-app文件" class="headerlink" title="准备.app文件"></a>准备<code>.app</code>文件</h2><p>接下来，就说下如何获取<code>.app</code>文件。</p>
<p>虽然是测试人员，不会对被测iOS项目贡献代码，但是也不能总是找研发帮忙编译生成<code>.app</code>文件。所以，在本地搭建完整的iOS项目开发环境还是很有必要的。</p>
<p>对于iOS开发环境的搭建，当前社区中应该已经有了很多完整的教程，我在这儿就不详细描述了，只简单说下我搭建过程中涉及到的几个点。</p>
<p>首先，Mac OSX、Xcode、Apple Developer Tools这些基础环境的安装，在上一篇文章中已经进行说明了；</p>
<p>然后，申请项目源码的访问权限，<code>git clone</code>到本地；</p>
<p>接着是项目依赖环境的问题；通常一个较大型的iOS项目都会引用许多第三方库，而这些依赖库并不会直接保存到项目仓库中，通常是采用<code>CocoaPods</code>进行管理；简单地说，<code>CocoaPods</code>是针对<code>Swift</code>和<code>Objective-C</code>项目的依赖管理器，类似于Java中的<code>Maven</code>，Ruby中的<code>Gem</code>，Python中的<code>pip</code>。</p>
<p>当然，iOS项目的依赖管理工具也不是只有<code>CocoaPods</code>一个，如果是采用的别的依赖管理器，请自行查找对应的资料。</p>
<p>采用<code>CocoaPods</code>管理的项目，在项目根目录下会包含<code>Podfile</code>和<code>Podfile.lock</code>文件，里面记录了当前项目依赖的第三方库以及对应的版本号。</p>
<p>安装<code>CocoaPods</code>很简单，采用<code>gem</code>即可。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo gem install cocoapods</div></pre></td></tr></table></figure>
<p>然后，进入到iOS项目的目录，执行<code>pod install</code>命令即可安装当前项目的所有依赖。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> Project_Folder</div><div class="line">$ pod install</div><div class="line">Re-creating CocoaPods due to major version update.</div><div class="line">Analyzing dependencies</div><div class="line">.....（略）</div><div class="line">Downloading dependencies</div><div class="line">.....（略）</div><div class="line">Generating Pods project</div><div class="line">Integrating client project</div><div class="line">Sending stats</div><div class="line">Pod installation complete! There are 27 dependencies from the Podfile and 28 total pods installed.</div></pre></td></tr></table></figure>
<p>关于<code>CocoaPods</code>的更多信息，请自行查看<a href="https://cocoapods.org" target="_blank" rel="external">官方网站</a></p>
<p>在依赖安装完成后，正常情况下，就可以在Xcode中编译项目了。</p>
<p>没有别的需要注意的，将target选择为模拟器（iOS Simulator）即可。而且针对模拟器进行编译时，也不会涉及到开发者证书的问题，项目配置上会简单很多。待后续讲到真机上的自动化测试时，我再对证书方面的内容进行补充。</p>
<p>编译完成后，在Products目录下，就可以看到<code>XXX.app</code>文件，这里的<code>XXX</code>就是项目名称；然后，选中<code>XXX.app</code>文件，【Show in Finder】，即可在文件目录中定位到该文件。</p>
<p>接下来，将<code>XXX.app</code>文件拷贝出来，或者复制该文件的<code>Full path</code>，怎样都行，只要在<code>Appium</code>的<code>App Path</code>中能定位到该文件就行。</p>
<h2 id="模拟器中运行iOS应用"><a href="#模拟器中运行iOS应用" class="headerlink" title="模拟器中运行iOS应用"></a>模拟器中运行iOS应用</h2><p>被测应用<code>.app</code>准备就绪后，接下来就可以在iOS模拟器中运行了。</p>
<p>回到前面的那张图。启动<code>Appium app</code>后，对于模拟器运行的情况，在<code>iOS Settings</code>中必须设置的参数项就3个，<code>App Path</code>、<code>Force Device</code>和<code>Platform Version</code>。对于真机运行的情况，后续再单独进行说明。</p>
<p>设置完毕后，点击【Launch】，启动<code>Appium Server</code>。</p>
<p><img src="/images/Appium_Inspector_Button.jpg" alt=""></p>
<p>然后，点击图中红框处的按钮，即可通过<code>Inspector</code>启动模拟器，并在模拟器中加载iOS应用。</p>
<p><img src="/images/Appium_iOS_Simulator_Console.jpg" alt=""></p>
<p>在模拟器中，我们可以像在真机中一样，体验被测应用的各项功能；并且，在Appium的日志台中，可以实时查看到日志信息。</p>
<h2 id="经历的一个坑"><a href="#经历的一个坑" class="headerlink" title="经历的一个坑"></a>经历的一个坑</h2><p>整个过程是挺简单的，不过，在探索过程中我还是有遇到一个坑。</p>
<p>通过<code>Inspector</code>启动模拟器时，总是弹框报错，报错形式如下。</p>
<p><img src="/images/Appium_Inspector_Error.jpg" alt=""></p>
<p>刚开始出现这问题时百思不得其解，因为提示的信息并不明显，Google了好一阵也没找到原因。最后只有详细去看日志信息，才发现问题所在。</p>
<p>在日志中，发现的报错信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[iOS] Error: Could not find a device to launch. You requested &apos;iPhone 6 (8.4)&apos;, but the available devices were: [&quot;Apple TV 1080p (9.2) [98638D25-7C82-48DF-BDCA-7F682F951533] (Simulator)&quot;,&quot;iPad 2 (9.2) [5E22F53E-EAB3-45DF-A1DD-10F58E920679] (Simulator)&quot;,&quot;iPad 2 (9.3) [4B2D2F9A-C099-4C13-8DE9-27C826A521C2] (Simulator)&quot;,&quot;iPad Air (9.2) [825E4997-9CD8-4225-9977-4C7AE2C98389] (Simulator)&quot;,&quot;iPad Air (9.3) [E4523799-E35F-4499-832B-12CF33F09144] (Simulator)&quot;,&quot;iPad Air 2 (9.2) [8057039D-F848-453E-97EC-2F75CAEA2E77] (Simulator)&quot;,&quot;iPad Air 2 (9.3) [0B8F49DA-832A-4248-BA1D-9DA5D11E31FD] (Simulator)&quot;,&quot;iPad Pro (9.2) [AF1F2D06-3067-41B5-AC2B-4B0ED88BF5D9] (Simulator)&quot;,&quot;iPad Pro (9.3) [C39617A6-9D91-4C0B-B25B-741BD57B016C] (Simulator)&quot;,&quot;iPad Retina (9.2) [D3C694E1-E3B4-47BE-AB5E-80B3D4E22FC2] (Simulator)&quot;,&quot;iPad Retina (9.3) [907C7B06-ED2C-48AC-AC46-04E4AD6E0CA3] (Simulator)&quot;,&quot;iPhone 4s (9.2) [1A786195-94E3-4908-8309-7B66D84E4619] (Simulator)&quot;,&quot;iPhone 4s (9.3) [3F76F34B-5A8F-4FD1-928D-56F84C192DDD] (Simulator)&quot;,&quot;iPhone 5 (9.2) [0D79A4CA-71EB-48A6-9EE4-172BEF3EB4E0] (Simulator)&quot;,&quot;iPhone 5 (9.3) [04270D44-F831-4253-95F2-3D205D2BC0D9] (Simulator)&quot;,&quot;iPhone 5s (9.2) [13A16C07-3C5B-4B04-A94B-B40A63238958] (Simulator)&quot;,&quot;iPhone 5s (9.3) [D30A7B34-BA01-4203-80DA-FAEA436725F9] (Simulator)&quot;,&quot;iPhone 6 (9.2) [5D01650F-2A31-4D53-A47A-CCF7FD552ADD] (Simulator)&quot;,&quot;iPhone 6 (9.3) [2F0810F6-C73B-4BA4-93BA-06D4B6D96BDA] (Simulator)&quot;,&quot;iPhone 6 Plus (9.2) [9A840B78-E6CE-4D18-BE83-16B590411641] (Simulator)&quot;,&quot;iPhone 6 Plus (9.3) [27C6557A-B09D-4D8A-9846-DA8FE0A8E8D5] (Simulator)&quot;,&quot;iPhone 6s (9.2) [E7F5B8A5-0E85-404F-A4D4-191D63E7EC1B] (Simulator)&quot;,&quot;iPhone 6s (9.3) [6F702911-13C2-472C-9ECD-BADD4385CB77] (Simulator)&quot;,&quot;iPhone 6s (9.3) + Apple Watch - 38mm (2.2) [B63FFAA4-00A4-473B-9462-3664F41F9001] (Simulator)&quot;,&quot;iPhone 6s Plus (9.2) [58837F78-511A-4F0B-9DDF-782E3B9935BD] (Simulator)&quot;,&quot;iPhone 6s Plus (9.3) [C31003C6-DCE2-414D-AD7F-376F6FA995B0] (Simulator)&quot;,&quot;iPhone 6s Plus (9.3) + Apple Watch - 42mm (2.2) [E3154768-CA23-45CC-90E5-2D0386A57B7D] (Simulator)&quot;]</div></pre></td></tr></table></figure>
<p>问题在于，我设置<code>iOS Settings</code>时，将<code>Force Device</code>设置为”iPhone 6”，将<code>Platform Version</code>设置为“8.4”，但是经过组合，<code>iPhone 6 (8.4)</code>并不在可用的模拟器设备列表中。</p>
<p>再来看日志中提示的可用设备，发现“iPhone 6”设备对应的<code>Platform Version</code>只有“9.2”和“9.3”。然后回到<code>iOS Settings</code>，发现<code>Platform Version</code>的下拉框可选项就没有“9.2”和“9.3”，最新的一个可选版本也就是“8.4”。</p>
<p><img src="/images/Appium_iOS_Settings_bug.jpg" alt=""></p>
<p>这应该是<code>Appium app</code>的一个bug吧。不过好在<code>Platform Version</code>参数虽然是通过下拉框选择，但是也可以在框内直接填写内容。于是我在<code>Platform Version</code>设置框内填写为“9.3”，然后再次启动时，发现iOS模拟器就可以正常启动了。</p>
<h2 id="To-be-continued-…"><a href="#To-be-continued-…" class="headerlink" title="To be continued …"></a>To be continued …</h2><p>现在，我们已经成功地通过Appium Inspector调用模拟器并运行iOS应用，接下来，我们就要开始尝试编写自动化测试用例了。</p>
<p>在下一篇文章中，我们将对Appium Inspector的功能进行熟悉，通过Inspector来查看iOS应用的UI元素信息，并尝试采用脚本语言与UI进行交互操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中，我对本系列教程的项目背景进行了介绍，并对自动化测试平台的建设进行了规划。&lt;/p&gt;
&lt;p&gt;在本文中，我将在已准备就绪的iOS自动化测试环境的基础上，通过Appium调用模拟器运行iOS应用。内容很是基础，熟悉的同学可直接略过。&lt;/p&gt;
&lt;h2 id=&quot;iOS应
    
    </summary>
    
    
      <category term="AutomationTest" scheme="http://debugtalk.com/tags/AutomationTest/"/>
    
      <category term="Appium" scheme="http://debugtalk.com/tags/Appium/"/>
    
      <category term="F0T1" scheme="http://debugtalk.com/tags/F0T1/"/>
    
      <category term="iOS" scheme="http://debugtalk.com/tags/iOS/"/>
    
      <category term="Simulator" scheme="http://debugtalk.com/tags/Simulator/"/>
    
  </entry>
  
  <entry>
    <title>从0到1搭建移动App功能自动化测试平台（0）：背景介绍和平台规划</title>
    <link href="http://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-backgroud-introduction/"/>
    <id>http://debugtalk.com/post/build-app-automated-test-platform-from-0-to-1-backgroud-introduction/</id>
    <published>2016-05-19T16:00:00.000Z</published>
    <updated>2016-07-23T07:58:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近新加入DJI的某项目组（以下均已M指代），需要从零开始搭建功能自动化测试平台。</p>
<p>简单地说，M是一个典型的移动互联网产品，客户端包括iOS和Android，并在app中通过WebView嵌入了H5，后端基于Ruby on Rails实现。</p>
<p>当前阶段，M项目除了Rails Server端采用Jenkins+RSpec实现了部分的持续集成功能外，客户端部分的部署和测试工作都还是完全依赖于手工操作。</p>
<p>基于当前项目的开发模式，我对整个M项目实现持续集成自动化测试的架构流程进行了规划，初步计划的架构图如下图所示。最终的目标是希望能实现：不管是Rails Server，还是App(iOS/Android)，以及H5，当任意部分存在代码提交时，系统能自动拉取最新代码进行部署并执行自动化回归测试，及时地将执行情况反馈给开发人员。</p>
<p><img src="/images/DJI_Plus_Automated_Test_Platform.jpg" alt=""></p>
<p>目标确定后，便是分阶段进行实现，需要开发的模块包括：</p>
<ul>
<li>自动化测试平台（Automated Test Platform）：满足iOS/Android/H5的自动化功能测试，包括模拟器和真机的测试；</li>
<li>测试管理平台（Test Management Platform）：实现自动化测试用例管理、手动下发测试任务、测试结果报表展现、Dashboard等功能；</li>
<li>打包平台（Pack System）：实现iOS/Android的自动化构建；</li>
<li>服务端自动化测试（Rails）：将服务端Rails的自动化测试接入测试管理平台；</li>
<li>持续集成流程打通：对Jenkins进行二次开发，与测试管理平台打通，实现全流程的持续集成自动化测试。</li>
</ul>
<p>而本系列教程，《从0到1搭建移动App功能自动化测试平台》，便是对整个实践过程的一个记录。</p>
<p>需要说明的是，之前我个人的工作经历主要在服务端性能测试、Android客户端性能测试（测试开发）方向，对于客户端的自动化测试基本上没有经验积累，特别是iOS系统的测试，以前更是完全没有接触过。因此本系列教程只能算是个人在探索路上的学习总结和记录，可能会存在一些错误的观点，还请前辈们多多指教。</p>
<h2 id="自动化测试框架的选择"><a href="#自动化测试框架的选择" class="headerlink" title="自动化测试框架的选择"></a>自动化测试框架的选择</h2><p>在愿景图中，绿色方框（Automated Test Platform）负责移动应用客户端（iOS/Android/H5）自动化测试的调度和执行，是整个自动化测试平台的核心。</p>
<p>因此，在搭建自动化测试平台之前，首先需要选择一个合适的自动化测试框架。</p>
<p>对于移动应用的自动化测试框架，当前市面上已经有很多成熟的开源项目。针对当前项目的实际情况，我主要参考如下选择标准：</p>
<ul>
<li>同时支持iOS、Android、H5，且尽量能保持接口统一，减少开发维护成本；</li>
<li>编程语言支持Python/Ruby；</li>
<li>用户量大，文档丰富。</li>
</ul>
<p>经过筛选，Appium无疑是最佳的选择。</p>
<h2 id="Appium简介"><a href="#Appium简介" class="headerlink" title="Appium简介"></a>Appium简介</h2><p>对于Appium的详细介绍，大家可参考<a href="http://appium.io/" target="_blank" rel="external">Appium</a>官方文档，我就不再重复引用。</p>
<p>不过对于Appium，仍然有几点很赞的理念值得强调。</p>
<ul>
<li>采用Appium时，无需对被测应用做任何修改，也无需嵌入任何东西；</li>
<li>Appium对iOS和Android的原生自动化测试框架进行了封装，并提供了统一的API（WebDriver API），减少了自动化测试代码的维护工作量；</li>
<li>Appium采用Client-Server的架构设计，并采用标准的HTTP通信协议；Server端负责与iOS/Android原生测试框架交互，无需测试人员关注细节实现；Client端基本上可以采用任意主流编程语言编写测试用例，减少了学习成本。</li>
</ul>
<h2 id="环境准备（iOS）"><a href="#环境准备（iOS）" class="headerlink" title="环境准备（iOS）"></a>环境准备（iOS）</h2><p>在Appium中测试iOS时，依赖于Apple开发环境，因此，在运行Appium之前需要先确保如下环境安装正确。</p>
<ul>
<li>Mac OS X &gt;= 10.7</li>
<li>XCode &gt;= 4.6.3</li>
<li>Apple Developer Tools (iPhone simulator SDK, command line tools)</li>
</ul>
<p>如上几个环境安装比较简单，直接在Apple Store中安装即可。</p>
<p>在安装Appium之前，为了确保Appium的相关依赖已经准备就绪，可以使用<code>appium-doctor</code>来进行验证。</p>
<p><a href="https://github.com/appium/appium-doctor" target="_blank" rel="external"><code>appium-doctor</code></a>是一个用于验证appium安装环境的工具，可以诊断出<code>Node/iOS/Android</code>环境配置方面的常见问题。</p>
<p><code>appium-doctor</code>采用<code>node.js</code>编写，采用<code>npm</code>即可在Terminal中进行安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install appium-doctor -g</div></pre></td></tr></table></figure>
<p>安装完毕后，执行<code>appium-doctor</code>命令即可对<code>Appium</code>的环境依赖情况进行检测；指定<code>--ios</code>时只针对iOS环境配置进行检测，指定<code>--android</code>参数时只针对Android环境配置进行检测，若不指定则同时对iOS和Android环境进行检测。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ appium-doctor --ios                                                                                                                               </div><div class="line">info AppiumDoctor <span class="comment">### Diagnostic starting ###</span></div><div class="line">info AppiumDoctor  ✔ Xcode is installed at: /Applications/Xcode.app/Contents/Developer</div><div class="line">info AppiumDoctor  ✔ Xcode Command Line Tools are installed.</div><div class="line">info AppiumDoctor  ✔ DevToolsSecurity is enabled.</div><div class="line">info AppiumDoctor  ✔ The Authorization DB is <span class="built_in">set</span> up properly.</div><div class="line">info AppiumDoctor  ✔ The Node.js binary was found at: /usr/<span class="built_in">local</span>/bin/node</div><div class="line">info AppiumDoctor  ✔ HOME is <span class="built_in">set</span> to: /Users/Leo</div><div class="line">info AppiumDoctor <span class="comment">### Diagnostic completed, no fix needed. ###</span></div><div class="line">info AppiumDoctor</div><div class="line">info AppiumDoctor Everything looks good, <span class="built_in">bye</span>!</div><div class="line">info AppiumDoctor</div></pre></td></tr></table></figure>
<p>若检测结果全部通过，则说明Appium的相关依赖已经准备就绪，接下来可以继续安装Appium。</p>
<h2 id="安装Appium"><a href="#安装Appium" class="headerlink" title="安装Appium"></a>安装Appium</h2><p>根据前面的介绍，Appium采用Client-Server的架构设计，因此安装Appium时需要分别安装Server部分和Client部分。</p>
<p>通常情况下，我们说的Appium都是指代的Server部分。Appium的安装有多种方式：可以通过源码编译安装，也可以在Terminal中通过<code>npm</code>命令安装，另一种是直接下载<a href="https://github.com/appium/appium/releases" target="_blank" rel="external"><code>appium.dmg</code></a>后安装应用程序。</p>
<p>在这里推荐运行<code>Appium app</code>的方式，除了GUI界面操作更直观以外，更重要的一个原因是，相比于命令行运行方式，<code>Appium app</code>多了一个<code>Inspector</code>模块，可以调用模拟器运行被测应用程序，并且可以很方便地在预览页面中查看UI元素的层级结构和详细控件属性，极大地提高编写测试脚本的效率。</p>
<p>至于Client部分，其实我们原本可以不安装任何东西，只需要任意选择一门开发语言，然后直接基于WebDriver的C/S协议（JSON Wire Protocol）即可编写自动化测试代码。但是这样做的话工作量会比较大，因为要去处理一些跟协议相关的工作。所幸Appium项目已经针对众多主流的编程语言，将底层协议处理相关的工作封装为Library，通过调用这些Library，可以极大地简化我们编写测试用例的工作量。</p>
<p>而说的需要安装的Client部分，其实也就是安装这些Library。选定编写测试用例的语言后，我们就可以针对性地进行安装。</p>
<p>例如，如果选择Ruby语言，那么需要安装的Library就是<code>appium_lib</code>，安装方式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gem install appium_lib</div></pre></td></tr></table></figure>
<p>如果选择Python语言，那么需要安装的Library就是<code>Appium-Python-Client</code>，安装方式如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install Appium-Python-Client</div></pre></td></tr></table></figure>
<p>对于其它编程语言，请自行参考官方文档。</p>
<h2 id="To-be-continued-…"><a href="#To-be-continued-…" class="headerlink" title="To be continued …"></a>To be continued …</h2><p>iOS的自动化测试环境已基本准备就绪了，接下来我们想做的第一件事，就是在模拟器中运行iOS应用。</p>
<p>在下一篇文章中，我们将从clone项目源码为起点，编译生成iOS app，在Appium中调用模拟器中运行iOS app，并分享实践过程中遇到的一些坑。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近新加入DJI的某项目组（以下均已M指代），需要从零开始搭建功能自动化测试平台。&lt;/p&gt;
&lt;p&gt;简单地说，M是一个典型的移动互联网产品，客
    
    </summary>
    
    
      <category term="AutomationTest" scheme="http://debugtalk.com/tags/AutomationTest/"/>
    
      <category term="Appium" scheme="http://debugtalk.com/tags/Appium/"/>
    
      <category term="F0T1" scheme="http://debugtalk.com/tags/F0T1/"/>
    
  </entry>
  
  <entry>
    <title>Android App持续集成性能测试：启动流量（2）</title>
    <link href="http://debugtalk.com/post/Android-performance-test-start-traffic-tcpdump-wireshark/"/>
    <id>http://debugtalk.com/post/Android-performance-test-start-traffic-tcpdump-wireshark/</id>
    <published>2016-05-02T16:00:00.000Z</published>
    <updated>2016-07-23T07:39:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章中，介绍了一种测试Android App启动流量的方法。当时也提到了，通过读取<code>/proc/uid_stat/&lt;UID&gt;/</code>目录下的<code>tcp_rcv</code>和<code>tcp_snd</code>文件，只能得到App的流量总值，无法得到更细化的数据。</p>
<p>例如，UC浏览器国际版在启动后，会和美国的服务器进行通讯交互，如果我们想测试浏览器在启动后与美国服务器的通讯流量，要怎么实现呢？。</p>
<p>本文便是针对这类场景的测试需求，讲解如何采用<code>tcpdump</code>测试得到更细化的流量数据。</p>
<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p><code>tcpdump</code>，是一个在Unix-like系统中通用的网络抓包工具，当然，这个工具在Android系统中也是可以使用的。</p>
<p>对于工具本身，本文不做过多介绍。为了防止有读者之前完全没有<code>tcpdump</code>的使用经验，在这里我只简单地进行几点说明：</p>
<ul>
<li>大多Android系统默认未集成tcpdump工具，我们需要事先将专门针对Android系统编译好的的tcpdump导入到Android系统，例如<code>/data/local/tmp/tcpdump</code>；当然，我们也不用自己编译，在<a href="http://www.androidtcpdump.com" target="_blank" rel="external"><code>androidtcpdump</code></a>网站就可以下载到编译好的tcpdump二进制文件。</li>
<li>运行<code>tcpdump</code>工具时需要root权限。</li>
<li>tcpdump命令支持许多参数，常见的有：<ul>
<li><code>-i</code>指定网卡（interface），<code>any</code>表示不限网卡；</li>
<li><code>-c</code>指定接收的packets数量，接收完成后自动停止抓包；</li>
<li><code>-w</code>指定输出文件，输出文件的格式为pcap；</li>
<li><code>-s</code>(<code>--snapshot-length</code>)指定在每个packet中最多截取的字节数，设置为0时表示截取上限取默认值262144；</li>
<li><code>-v</code>/<code>-vv</code>/<code>-vvv</code>，指定输出的详细程度，针对流量测试，我们不需要非常详尽的输出数据，取<code>-v</code>即可。</li>
</ul>
</li>
</ul>
<p>基于以上对<code>tcpdump</code>的介绍，我们要测试浏览器在启动后与美国服务器的通讯流量，就只需要先启动浏览器，然后在<code>adb shell</code>中执行以下命令即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1|shell@hammerhead:/ $ su -c /data/local/tmp/tcpdump -v -i any -s 0 -c 2000 -w /sdcard/us.pcap</div><div class="line">tcpdump: listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes</div><div class="line">2000 packets captured</div><div class="line">2024 packets received by filter</div><div class="line">0 packets dropped by kernel</div></pre></td></tr></table></figure>
<p>在这里之所有指定接收packets数为2000，是因为浏览器启动后并不是立即与美国服务器进行通讯。所以在这里设置了一个比较大的值，确保浏览器与美国服务器的异步通讯数据能包含在这2000packets之中。当然，这个2000只是一个工程实践得到的经验值，具体取多少还是要依赖于具体场景。</p>
<p>经过一段时间的抓包后，就生产了抓包结果，即<code>/sdcard/us.pcap</code>。</p>
<h2 id="人工分析pcap文件"><a href="#人工分析pcap文件" class="headerlink" title="人工分析pcap文件"></a>人工分析pcap文件</h2><p>拿到pcap文件只是第一步，我们必须要对这个文件进行解析才能得到我们想要的结果。</p>
<p>那么，通过什么方法解析pcap文件呢？</p>
<p>先简单介绍下pcap。pcap，即<code>packet capture</code>的缩写，是一种通用的网络抓包数据存储格式。既然是通用，因此它除了可以被<code>tcpdump</code>解析外，还支持被多种网络工具解析，其中，就包括大家熟知的<code>wireshark</code>。</p>
<p>至于为什么有了<code>tcpdump</code>还要用<code>wireshark</code>来解析，这主要还是因为<code>wireshark</code>是图形界面，操作和使用上更友好一些。</p>
<p>在<code>wireshark</code>中分析pcap文件十分简单，只需要直接打开文件，就可以看到抓包过程中捕获的所有网络通讯数据。不过，由于我们抓包获得的数据是系统层面的，除了我们关注的与美国服务器的通讯交互外，还包含了非常多的其它通讯信息。</p>
<p>好在<code>wireshark</code>有非常强大的筛选功能。对于本案例，我们可以先确定出美国服务器的host或IP，例如host为<code>ucus.ucweb.com</code>，那么我们就可以在筛选器中通过<code>http.host == &quot;ucus.ucweb.com&quot;</code>语句，即可筛选出所有本地与美国服务器的通讯交互数据。</p>
<p><img src="/images/wireshark_host_filter.png" alt=""></p>
<p>对于更丰富的筛选功能，大家可以根据实际需求查询<code>wireshark</code>的帮助文档，在此就不再进行展开。</p>
<p>从上图的筛选结果中可以看到，美国服务器的地址为<code>168.235.199.134</code>。那接下来如何查看通讯的流量大小呢？</p>
<p>首先，找出该次请求的<code>TCP Stream</code>。</p>
<p><img src="/images/wireshark_tcp_stream_menu.png" alt=""></p>
<p>在筛选出的<code>TCP Stream</code>中，将各条记录的Length进行求和，即可得到总的大小。</p>
<p><img src="/images/wireshark_tcp_stream_data.png" alt=""></p>
<p>例如，发送流量的总和，即<code>100.84.126.160</code>-&gt;<code>168.235.199.134</code>的总和，加和总值为3722bytes；接收流量的总和，即<code>168.235.199.134</code>-&gt;<code>100.84.126.160</code>的总和，加和总值为6300bytes。</p>
<p>当然，这里只是为了讲解计算流量的原理，实际上，我们并不需要去进行这个计算，可以直接读取得到总值。</p>
<p>【Statistics】-&gt;【Endpoints】</p>
<p><img src="/images/wireshark_endpoints_menu.png" alt=""></p>
<p>在Endpoints界面中，选择<code>TCP</code> tab，勾选“Limit to display filter”，即可看到通讯流量汇总数据。</p>
<p><img src="/images/wireshark_tcp_stream_data.png" alt=""></p>
<p>可以看出，这个的汇总数值与前面计算得到的数值完全相同。</p>
<h2 id="自动化测试脚本"><a href="#自动化测试脚本" class="headerlink" title="自动化测试脚本"></a>自动化测试脚本</h2><p>通过前面的人工分析，我们已经掌握了分析特定流量的一般性方法。然而，要想将此种场景的流量测试加入持续集成自动化测试系统，采用以上方法显然是不行的。</p>
<p>那么，要怎样才能在代码中完成对pcap文件的分析呢？</p>
<p>好在已经有前辈做了相应的工作，在GitHub上就找到了一个开源项目<a href="https://github.com/andrewf/pcap2har" target="_blank" rel="external"><code>pcap2har</code></a>，可以实现对pcap文件的解析。</p>
<p><code>pcap2har</code>项目的详细介绍请大家自行查看项目文档。</p>
<p>针对本文中的测试场景，解析pcap文件的代码实现如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> dpkt</div><div class="line"><span class="keyword">from</span> pcap2har <span class="keyword">import</span> pcap</div><div class="line"><span class="keyword">from</span> pcap2har <span class="keyword">import</span> http</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsePcapFile</span><span class="params">(pcap_file, target_host)</span>:</span></div><div class="line">    <span class="comment"># parse pcap file</span></div><div class="line">    dispatcher = pcap.EasyParsePcap(filename=pcap_file)</div><div class="line"></div><div class="line">    traffic_total = <span class="number">0</span></div><div class="line">    traffic_receive_total = <span class="number">0</span></div><div class="line">    traffic_send_total = <span class="number">0</span></div><div class="line">    url_list = []</div><div class="line"></div><div class="line">    <span class="comment"># stream为tcp数据流，当为长链接时一个tcp流里面可以有多个http请求</span></div><div class="line">    <span class="keyword">for</span> stream <span class="keyword">in</span> dispatcher.tcp.flows():</div><div class="line">        <span class="comment"># fwd为请求大小，如果小于200则肯定不是正常的HTTP请求，忽略</span></div><div class="line">        <span class="keyword">if</span> stream.fwd.caplen &lt; <span class="number">200</span>:</div><div class="line">            <span class="keyword">continue</span></div><div class="line"></div><div class="line">        pointer = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> pointer &lt; len(stream.fwd.data):</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                myrequest = http.Request(stream.fwd, pointer) <span class="comment">#解析请求头</span></div><div class="line">            <span class="keyword">except</span> dpkt.Error <span class="keyword">as</span> error:  <span class="comment"># if the message failed</span></div><div class="line">                <span class="keyword">break</span></div><div class="line">            <span class="keyword">except</span>:</div><div class="line">                <span class="keyword">raise</span></div><div class="line"></div><div class="line">            pointer += myrequest.data_consumed</div><div class="line">            myhead = myrequest.msg.headers</div><div class="line"></div><div class="line">            <span class="comment"># 请求头大小&lt;200时忽略</span></div><div class="line">            <span class="keyword">if</span> myrequest.data_consumed &lt; <span class="number">200</span>:</div><div class="line">                <span class="keyword">continue</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> myhead[<span class="string">"host"</span>] == target_host:</div><div class="line">                traffic_receive_total += stream.rev.caplen</div><div class="line">                traffic_send_total += stream.fwd.caplen</div><div class="line">                traffic_total += stream.streamlen</div><div class="line">                url_list.append(myrequest.fullurl)</div><div class="line"></div><div class="line">    traffic_data = &#123;</div><div class="line">        <span class="string">'total'</span>: traffic_total,</div><div class="line">        <span class="string">'tcp_snd'</span>: traffic_send_total,</div><div class="line">        <span class="string">'tcp_rcv'</span>: traffic_receive_total,</div><div class="line">        <span class="string">'url_list'</span>: url_list</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> traffic_data</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    pcap_file = <span class="string">""</span></div><div class="line">    target_host = <span class="string">"ucus.ucweb.com"</span></div><div class="line">    <span class="keyword">print</span> parsePcapFile(pcap_file, target_host)</div><div class="line">    <span class="comment"># output: &#123;'url_list': ['http://ucus.ucweb.com/usquery.php'], 'total': 10022, 'tcp_rcv': 6300, 'tcp_snd': 3722&#125;</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章中，介绍了一种测试Android App启动流量的方法。当时也提到了，通过读取&lt;code&gt;/proc/uid_stat/&amp;lt;UID&amp;gt;/&lt;/code&gt;目录下的&lt;code&gt;tcp_rcv&lt;/code&gt;和&lt;code&gt;tcp_snd&lt;/code&gt;文件，只能得到
    
    </summary>
    
    
      <category term="Android" scheme="http://debugtalk.com/tags/Android/"/>
    
      <category term="流量测试" scheme="http://debugtalk.com/tags/%E6%B5%81%E9%87%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="tcpdump" scheme="http://debugtalk.com/tags/tcpdump/"/>
    
      <category term="wireshark" scheme="http://debugtalk.com/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>Android App持续集成性能测试：启动流量（1）</title>
    <link href="http://debugtalk.com/post/Android-performance-test-start-traffic-uid-stat/"/>
    <id>http://debugtalk.com/post/Android-performance-test-start-traffic-uid-stat/</id>
    <published>2016-05-02T16:00:00.000Z</published>
    <updated>2016-07-23T07:39:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文对Android App的启动流量测试进行介绍。这里的启动流量指的是网络流量，即App在启动时发起网络请求和接收网络响应时传输的网络数据量。</p>
<p>说起流量，也许大家的第一反应就是tcpdump/wireshark这类网络抓包工具。的确，Android系统确实也支持<code>tcpdump</code>工具，通过<code>tcpdump</code>，我们可以实现非常精准的流量测试。但<code>tcpdump</code>也有个问题，就是它捕捉到的流量是系统层面的，我们很难区分捕捉得到的流量数据是否都是当前apk产生的。</p>
<p>其实，对于特定apk的整体流量数据，在Android系统中都会存储到对应文件中，我们完全可以通过读取对应文件来获得当前apk的流量信息。</p>
<h2 id="get-app-UID"><a href="#get-app-UID" class="headerlink" title="get app UID"></a>get app UID</h2><p>与流量相关的状态数据存储在<code>/proc/uid_stat/&lt;UID&gt;/</code>目录下，其中，<code>&lt;UID&gt;</code>表示apk对应的UID。</p>
<p>关于UID，简单地进行下说明。在Linux系统中，UID表示的是User Identifier，主要用于表示是哪位用户运行了该程序。但在Android系统中，由于Android系统本身就为单用户系统，这时UID就被赋予了新的使命，主要用于实现数据共享。具体地，Android系统为每个应用都分配了一个UID，不同apk的UID几乎都是互不相同的，而对于不同UID的apk，不能共享数据资源。之所以用“几乎”，是因为有时候同一厂家会存在多个产品，并且希望能在多个apk之间实现数据共享，这个时候，便可通过在menifest配置文件中指定相同的sharedUserId，然后在Android系统中安装应用时便会分配相同的UID。</p>
<p>获取app UID的方式有多种，最简单的方式应该还是从<code>/data/system/packages.list</code>中读取，并通过apk的<code>&lt;PKGNAME&gt;</code>找到对应的UID。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@hammerhead:/ # cat /data/system/packages.list | grep com.UCMobile.trunk</div><div class="line">com.UCMobile.trunk 10084 0 /data/data/com.UCMobile.trunk default 3003,1028,1015</div></pre></td></tr></table></figure>
<p>在这里，10084即是<code>com.UCMobile.trunk</code>的UID。</p>
<h2 id="获取流量数据"><a href="#获取流量数据" class="headerlink" title="获取流量数据"></a>获取流量数据</h2><p>流量数据分为接收流量（tcp_rcv）和发送流量（tcp_snd）两部分，这两个状态数值我们可以通过读取<code>/proc/uid_stat/&lt;UID&gt;</code>目录下的两个文件得到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">shell@hammerhead:/ $ cat /proc/uid_stat/10084/tcp_rcv</div><div class="line">3446837</div><div class="line">shell@hammerhead:/ $ cat /proc/uid_stat/10084/tcp_snd</div><div class="line">134366</div></pre></td></tr></table></figure>
<p>通过这种方式，我们就可以读取得到指定apk在当前时刻的累计流量数值。</p>
<h2 id="获得启动流量数据"><a href="#获得启动流量数据" class="headerlink" title="获得启动流量数据"></a>获得启动流量数据</h2><p>有了前面的基础，我们要测试启动流量就很好实现了。只需要在启动前采集下累计流量数值，然后启动应用，完成启动后再采集一次累计流量数值，前后两次累计数值的差值便是当次启动耗费的流量数。需要注意的是，由于很多时候apk在启动后，会在系统后台异步加载一些数据资源，因此为了保证我们采集到当次启动耗费的全部流量数值，我们在启动应用后最好能等待一段时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">root@hammerhead:/ # cat /proc/uid_stat/10084/tcp_snd</div><div class="line">15068</div><div class="line">root@hammerhead:/ # cat /proc/uid_stat/10084/tcp_rcv</div><div class="line">98021</div><div class="line"></div><div class="line"># start app activity, sleep 10s</div><div class="line"></div><div class="line">root@hammerhead:/ # cat /proc/uid_stat/10142/tcp_snd</div><div class="line">23268</div><div class="line">root@hammerhead:/ # cat /proc/uid_stat/10142/tcp_rcv</div><div class="line">965651</div></pre></td></tr></table></figure>
<p>采集到前后两次流量数值后，即可计算得到当次启动耗费的总流量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">当次启动总流量 = (23268 + 965651) - (15068 + 98021) = 875830 bytes</div></pre></td></tr></table></figure>
<p>当然，这里的启动还分为好几种，包括首次安装启动、非首次安装启动、覆盖安装启动等。具体的启动方式可根据实际场景来定，但在统计流量的方法方面都是相同的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讲解了Android App启动流量测试的一种方法。然而，本次介绍的方法也存在一定局限性，因为<code>/proc/uid_stat/&lt;UID&gt;/</code>目录下的<code>tcp_rcv</code>和<code>tcp_snd</code>文件中都只记录了总值，如果我们只关注总体的流量数值还好，但要是我们希望能测试得到更细化的数据，该方法就没法满足我们的测试需求了。</p>
<p>举个例子，UC浏览器国际版在启动后，会和美国的服务器进行通讯交互。现在，我们想测试UC浏览器国际版在启动后与美国服务器的通讯流量。</p>
<p>显然，本文中介绍的方法是没法实现上述例子中的测试需求的。那例子中的场景要怎么测呢？这就还是得用到<code>tcpdump</code>，在下一篇文章中我会再详细进行介绍。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对Android App的启动流量测试进行介绍。这里的启动流量指的是网络流量，即App在启动时发起网络请求和接收网络响应时传输的网络数据量。&lt;/p&gt;
&lt;p&gt;说起流量，也许大家的第一反应就是tcpdump/wireshark这类网络抓包工具。的确，Android系统确实也
    
    </summary>
    
    
      <category term="Android" scheme="http://debugtalk.com/tags/Android/"/>
    
      <category term="流量测试" scheme="http://debugtalk.com/tags/%E6%B5%81%E9%87%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>通过API远程管理Jenkins</title>
    <link href="http://debugtalk.com/post/manage-Jenkins-via-remote-api/"/>
    <id>http://debugtalk.com/post/manage-Jenkins-via-remote-api/</id>
    <published>2016-05-01T16:00:00.000Z</published>
    <updated>2016-07-22T11:07:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>最近接到一个需求，需要对公司内部的Android性能测试平台的分支管理模块进行改造。</p>
<p>为了更好地说明问题，在下图中展示了一个精简的持续集成测试系统。</p>
<p><img src="/images/Jenkins-DroidTestbed.png" alt=""></p>
<p>在该系统中，Jenkins负责定时检测代码库（<code>Code Repository</code>）的代码更新情况，当检测到有新的代码提交时，自动采用最新的代码进行构建，并采用构建得到的包（apk）触发自动化测试平台（<code>DroidTestbed</code>）执行测试任务。</p>
<p>然后再说下分支管理模块。</p>
<p>由于我们的持续集成平台通常不止监控一个产品，而每个产品又不止监控一个tag（例如/trunk，/projects/cn/10.9.8），因此，我们的持续集成平台需要有分支管理的功能，即针对每一个产品的每一个tag，单独创建一个分支，并针对各个分支单独指定测试用例集合测试设备。</p>
<p>具体实现方面，出于单一职责的原则，我们对功能进行了如下划分：</p>
<ul>
<li>在Jenkins端针对每一个分支创建一个Job；</li>
<li>在<code>DroidTestbed</code>端配置测试资源，针对每一个分支分别绑定测试用例集和测试设备，每一个分支会存在一个单独的branch_id；</li>
<li>在Jenkins端的Job配置中，保存该分支在<code>DroidTestbed</code>中对应的<code>branch_id</code>，实现<code>Jenkins</code>与<code>DroidTestbed</code>的关联。</li>
</ul>
<p>整个过程看上去并没有什么问题，那为什么需要对分支管理模块进行改造呢？</p>
<p>问题就出现在分支配置上面。</p>
<p>试想一下，每次要新增或修改一个分支的时候，由于Jenkins端和DroidTestbed端的配置是独立的，那么我们就只能在两个平台上分别进行配置。</p>
<p>另一方面，配置工作本身也较为复杂，例如，在Jenkins端就需要设置的参数包括：repository_url，tag，ref_tag，ref_revision，branch_id，schedule，user_name等；而这其中的大部分参数同样也要在DroidTestbed端进行配置。</p>
<p>根据历史经验，但凡涉及到复杂且重复的手工操作时，就容易出错。实际情况的确是这样的。在该功能上线后，由于配置复杂，业务组的同学每次要新增一个监控分支时，都需要找到管理员来帮忙配置（说实话，管理员对业务同学能配置正确也没信心）；即使是管理员，也出现过好几次因为疏忽造成配置错误的情况。</p>
<p>那么，这个问题要怎么解决呢？</p>
<h2 id="Jenkins-Remote-API-的简介"><a href="#Jenkins-Remote-API-的简介" class="headerlink" title="Jenkins Remote API 的简介"></a>Jenkins Remote API 的简介</h2><p>绕了这么大一个圈子，终于引出本文的主题，Jenkins Remote API。</p>
<p>实际上，Jenkins本身支持丰富的API接口，我们通过远程调用接口，基本上可以实现所有需要的功能，例如：</p>
<ul>
<li>从Jenkins获取Job状态信息</li>
<li>触发Jenkins执行构建</li>
<li>创建、复制、修改、删除Job</li>
</ul>
<p>回到前面的案例，我们就可以将配置操作全部放在<code>DroidTestbed</code>中，只需要在保存配置项时，由<code>DroidTestbed</code>自动调用Jenkins的Remote API，即可实现配置的同步。</p>
<h2 id="Jenkins-Remote-API-的调用"><a href="#Jenkins-Remote-API-的调用" class="headerlink" title="Jenkins Remote API 的调用"></a>Jenkins Remote API 的调用</h2><p>现在我们来看下如何调用Jenkins的Remote API。</p>
<p>Jenkins的Remote API以<code>REST-like</code>的形式进行提供，通过对特定的API执行POST请求即可实现对Jenkins的操作。</p>
<p>例如，我们搭建的Jenkins站点为<code>http://jenkins.debugtalk.com:8080</code>，那么，访问<code>http://jenkins.debugtalk.com:8080/api</code>即可查看到该站点所有可用的API；若想若某个具体的Job进行操作，如job名称<code>android_core_dashboard_trunk</code>，它的管理页面为<code>http://jenkins.debugtalk.com:8080/job/android_core_dashboard_trunk</code>，那么我们访问<code>http://jenkins.debugtalk.com:8080/job/android_core_dashboard_trunk/api/</code>即可查看到该job可用的API。</p>
<p>更详细的POST调用方式的介绍可以参考Jenkins的官方<a href="https://wiki.jenkins-ci.org/display/JENKINS/Remote+access+API" target="_blank" rel="external">wiki</a>，在此就不过多进行介绍。</p>
<p>可以看出，通过对特定API执行POST请求操作较为原始，因为我们需要关注过多底层细节。事实上，当前已经有前辈针对这一痛点，对底层的POST操作细节进行了封装，形成了一些<code>wrapper</code>方便我们从上层进行更便捷的操作。</p>
<p>这类<code>wrapper</code>实现的功能类似，都可以方便我们在代码中通过更简洁的方式调用Jenkins API，实现对Jenkins的远程管理，我们只需要根据我们采用的具体编程语言来选择对应的<code>wrapper</code>即可。当然，如果没有找到合适的，我们也可以参照已有的开源<code>wrapper</code>，自己再造一个轮子，原理都是相同的。</p>
<p>在Jenkins的官方wiki中，推荐了两个较为成熟的<code>API wrapper</code>，一个是基于Python实现的<a href="https://github.com/salimfadhley/jenkinsapi" target="_blank" rel="external"><code>salimfadhley/jenkinsapi</code></a>，另一个是基于Ruby实现的<a href="https://github.com/arangamani/jenkins_api_client" target="_blank" rel="external"><code>arangamani/jenkins_api_client</code></a>。</p>
<p>以<code>salimfadhley/jenkinsapi</code>为例，通过使用<code>jenkinsapi</code>，我们在Python中就可以很方便地管理Jenkins。常见的操作方式示例如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> jenkinsapi</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> jenkinsapi.jenkins <span class="keyword">import</span> Jenkins</div><div class="line"></div><div class="line"><span class="comment"># 指定Jenkins实例</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>J = Jenkins(<span class="string">'http://jenkins.debugtalk.com:8080'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 查看Jenkins版本</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>J.version</div><div class="line"><span class="number">1.542</span></div><div class="line"></div><div class="line"><span class="comment"># 查看Jenkins的所有jobs</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>J.keys()</div><div class="line">[<span class="string">'foo'</span>, <span class="string">'test_jenkinsapi'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 查看指定job的配置信息</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>J[<span class="string">'test_jenkinsapi'</span>].get_config()</div><div class="line"></div><div class="line"><span class="comment"># 创建Jenkins job</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>jobName = <span class="string">'test_job'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>EMPTY_JOB_CONFIG = <span class="string">'''</span></div><div class="line">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</div><div class="line">&lt;project&gt;</div><div class="line">  &lt;actions&gt;jkkjjk&lt;/actions&gt;</div><div class="line">  &lt;description&gt;&lt;/description&gt;</div><div class="line">  &lt;keepDependencies&gt;false&lt;/keepDependencies&gt;</div><div class="line">  &lt;properties/&gt;</div><div class="line">  &lt;scm class="hudson.scm.NullSCM"/&gt;</div><div class="line">  &lt;canRoam&gt;true&lt;/canRoam&gt;</div><div class="line">  &lt;disabled&gt;false&lt;/disabled&gt;</div><div class="line">  &lt;blockBuildWhenDownstreamBuilding&gt;false&lt;/blockBuildWhenDownstreamBuilding&gt;</div><div class="line">  &lt;blockBuildWhenUpstreamBuilding&gt;false&lt;/blockBuildWhenUpstreamBuilding&gt;</div><div class="line">  &lt;triggers class="vector"/&gt;</div><div class="line">  &lt;concurrentBuild&gt;false&lt;/concurrentBuild&gt;</div><div class="line">  &lt;builders/&gt;</div><div class="line">  &lt;publishers/&gt;</div><div class="line">  &lt;buildWrappers/&gt;</div><div class="line">&lt;/project&gt;</div><div class="line">'''</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>new_job = J.create_job(jobName, EMPTY_JOB_CONFIG)</div><div class="line"></div><div class="line"><span class="comment"># 更新Jenkins job的配置</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> et</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>new_conf = new_job.get_config()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>root = et.fromstring(new_conf.strip())</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>builders = root.find(<span class="string">'builders'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>shell = et.SubElement(builders, <span class="string">'hudson.tasks.Shell'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>command = et.SubElement(shell, <span class="string">'command'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>command.text = <span class="string">"ls"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>J[jobName].update_config(et.tostring(root))</div><div class="line"></div><div class="line"><span class="comment"># 删除Jenkins job</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>J.delete_job(jobName)</div></pre></td></tr></table></figure>
<p>更多的使用方法可参考项目文档。</p>
<p>有些同学在认真研究了这些开源库后也许会说，官方文档已经翻遍了，但是文档中对用法的描述太少了，也没给出API调用的示例，还是不知道怎么使用啊。这个问题在开源库中的确也是普遍存在的。</p>
<p>介绍个技巧，通常优秀的开源库都会很重视测试，作者可能在文档中没有针对每一个API接口的调用方式进行说明，但通常会针对各个接口编写较为完整的测试代码。我们通过阅读测试代码，就可以充分了解API接口的使用方法了，这也比直接阅读文档有效率得多。</p>
<h2 id="Read-More-…"><a href="#Read-More-…" class="headerlink" title="Read More …"></a>Read More …</h2><p>最后，如果感觉上面给的示例还不够，还想看看在实际项目中如何远程管理Jenkins，那么可以关注我最近在做的一个开源项目。</p>
<p>先看下整体的系统架构图。</p>
<p><img src="/images/DroidTestbed-DroidMeter.png" alt=""></p>
<p>整个系统实现的功能是Android App的性能持续集成测试平台，主要由<code>DroidTestbed</code>和<code>DroidMeter</code>两部分组成。</p>
<p>其中，<code>DroidTestbed</code>部分采用<code>Ruby on Rails</code>编写，核心角色为测试任务管理，可实现测试资源（测试用例、测试设备等）配置，根据代码提交自动触发执行测试任务、测试设备自动化调度、测试任务手动下发，测试结果报表查看等。<code>DroidMeter</code>负责具体的性能测试执行，采用Python编写，可实现控制Android设备执行测试场景，采集性能测试数据，包括内存、启动时间、帧率、包大小、网速、流量等等。</p>
<p>本文暂时不对该系统进行过多介绍，我后续会单独对各个模块涉及到的技术展开进行详细介绍。如果感兴趣，可关注我的GitHub或微信公众号【DebugTalk】。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h2&gt;&lt;p&gt;最近接到一个需求，需要对公司内部的Android性能测试平台的分支管理模块进行改造。&lt;/p&gt;
&lt;p&gt;为了更好地说明问题，在下
    
    </summary>
    
    
      <category term="Jenkins" scheme="http://debugtalk.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>SQL语句中关于NULL的那些坑</title>
    <link href="http://debugtalk.com/post/traps-in-sql-null/"/>
    <id>http://debugtalk.com/post/traps-in-sql-null/</id>
    <published>2016-04-24T16:00:00.000Z</published>
    <updated>2016-07-22T11:07:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>今天在跟进公司内部测试平台线上问题的时候，发现一个忽略已久的问题。</p>
<p>为了简化问题描述，将其进行了抽象。</p>
<p>有一张数据表<code>qms_branch</code>，里面包含了一批形式如下所示的数据：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>types</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>dashboard_trunk</td>
<td>dashboard</td>
</tr>
<tr>
<td>2</td>
<td>monkey_trunk</td>
<td>monkey</td>
</tr>
<tr>
<td>3</td>
<td>dashboard_projects_10_9_9</td>
<td>dashboard</td>
</tr>
<tr>
<td>4</td>
<td>performance_trunk</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>performance_projects_10_9_8</td>
<td>performance</td>
</tr>
</tbody>
</table>
<p>在系统的某个页面中，需要展示出所有<code>dashboard</code>类型以外的分支，于是就采用如下方式进行查询（Rails）。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">branches = Qms::Branch.where(<span class="string">"types!='dashboard'"</span>)</div></pre></td></tr></table></figure>
<p>这个方式有问题么？</p>
<p>之前我是觉得没什么问题。但是在代码上线后，实际使用时发现部分分支没有加载出来，这就包括了<code>performance_trunk</code>分支。</p>
<p>然后就是问题定位，到MySQL的控制台采用SQL语句进行查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> qms_branch <span class="keyword">WHERE</span> types != <span class="string">'dashboard'</span></div></pre></td></tr></table></figure>
<p>发现在查询结果中的确没有包含<code>performance_trunk</code>分支。</p>
<p>这是什么原因呢？为什么在第4条数据中，<code>types</code>属性的值明明就不是<code>dashboard</code>，但是采用<code>types!=&#39;dashboard&#39;</code>就无法查询得到结果呢？</p>
<h2 id="原因追溯"><a href="#原因追溯" class="headerlink" title="原因追溯"></a>原因追溯</h2><p>查看数据表<code>qms_branch</code>的结构，看到<code>types</code>字段的属性为：<code>DEFAULT NULL</code>。</p>
<p>经过查询资料，在<a href="http://www.w3schools.com/sql/sql_null_values.asp" target="_blank" rel="external">w3schools</a>上找到了答案。</p>
<blockquote>
<ul>
<li>NULL is used as a placeholder for unknown or inapplicable values, it is treated differently from other values.</li>
<li>It is not possible to test for NULL values with comparison operators, such as =, &lt;, or &lt;&gt;. We will have to use the IS NULL and IS NOT NULL operators instead.</li>
</ul>
</blockquote>
<p>也就是说，在SQL中，<code>NULL</code>并不能采用<code>!=</code>与数值进行比较，若要进行比较，我们只能采用<code>IS NULL</code>或<code>IS NOT NULL</code>。</p>
<p>于是，我们将SQL语句改为如下形式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> qms_branch <span class="keyword">WHERE</span> types <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">or</span> types != <span class="string">'dashboard'</span></div></pre></td></tr></table></figure>
<p>再次查询时，结果集就包含<code>performance_trunk</code>分支了。</p>
<h2 id="问题延伸"><a href="#问题延伸" class="headerlink" title="问题延伸"></a>问题延伸</h2><p>通过上面例子，我们知道在对NULL进行判断处理时，只能采用<code>IS NULL</code>或<code>IS NOT NULL</code>，而不能采用<code>=, &lt;, &lt;&gt;, !=</code>这些操作符。</p>
<p>那除此之外，还有别的可能存在的坑么？</p>
<p>再看一个例子：</p>
<p>有一张数据表<code>table_foo</code>，其中有一个字段<code>value_field</code>，我们想从这张表中筛选出所有<code>value_field</code>为’value1’，’value2’或NULL的记录。</p>
<p>那么，我们采用<code>IN</code>操作符，通过如下SQL语句进行查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_foo <span class="keyword">WHERE</span> value_field <span class="keyword">IN</span> (<span class="string">'value1'</span>, <span class="string">'value2'</span>, <span class="literal">NULL</span>)</div></pre></td></tr></table></figure>
<p>这会存在问题么？我们并没有采用<code>=, &lt;, &lt;&gt;, !=</code>对NULL进行比较哦。</p>
<p>答案是同样存在问题！</p>
<p>因为在SQL中，<code>IN</code>语句会被转换为多个<code>=</code>语句。例如，上面例子中的SQL在执行时就会被转换为如下SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_foo <span class="keyword">WHERE</span> value_field = <span class="string">'value1'</span> <span class="keyword">OR</span> value_field = <span class="string">'value2'</span> <span class="keyword">OR</span> value_field = <span class="literal">NULL</span></div></pre></td></tr></table></figure>
<p>而这个时候，执行<code>value_field = NULL</code>时就会出现问题了。</p>
<p>正确的做法应该是将<code>NULL</code>相关的判断独立出来，如下SQL才是正确的写法。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_foo <span class="keyword">WHERE</span> value_field <span class="keyword">IN</span> (<span class="string">'value1'</span>, <span class="string">'value2'</span>) <span class="keyword">OR</span> value_field <span class="keyword">IS</span> <span class="literal">NULL</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;今天在跟进公司内部测试平台线上问题的时候，发现一个忽略已久的问题。&lt;/p&gt;
&lt;p&gt;为了简化问题描述，将其进行了抽象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="http://debugtalk.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>对Android设备CPU进行锁频</title>
    <link href="http://debugtalk.com/post/Android-CPU-lock-frequency/"/>
    <id>http://debugtalk.com/post/Android-CPU-lock-frequency/</id>
    <published>2016-04-17T16:00:00.000Z</published>
    <updated>2016-07-23T07:29:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文对Android设备CPU的状态查看方法和锁频（lock frequency）方法进行详细介绍。这有什么用？作为测试工程师，你值得了解。</p>
<h2 id="CPU频率"><a href="#CPU频率" class="headerlink" title="CPU频率"></a>CPU频率</h2><p>首先说下CPU的频率。我们都知道，CPU的工作频率越高，运算就越快，但能耗也更高。然而很多时候，设备并不需要那么高的计算性能，这个时候，我们就希望能降低CPU的工作频率，追求较低的能耗，以此实现更长的待机时间。</p>
<p>基于此需求，当前电子设备的CPU都会存在多个工作频率，并能根据实际场景进行CPU频率的自动切换，以此达到平衡计算性能与能耗的目的。</p>
<h2 id="锁频的用途"><a href="#锁频的用途" class="headerlink" title="锁频的用途"></a>锁频的用途</h2><p>那么为什么需要锁频呢？</p>
<p>对于普通用户来说，可能对这些场景比较熟悉：</p>
<ul>
<li>在家用笔记本电脑玩游戏的时候，电脑连着电源，不在乎能耗，只想要尽可能高的性能，这个时候就选择高性能模式，即保持CPU在最高频率工作。</li>
<li>旅行途中使用笔记本电脑，靠电池供电，希望电脑能待机尽可能久，这时就选择省电模式，即CPU保持在最低频率运行。</li>
</ul>
<p>作为一名测试工程师，我们在进行软件测试的时候，为了让测试结果真实反映软件本身的效率，从控制变量法的角度，我们希望测试结果尽量不受到硬件本身的影响。这个时候，我们就可以尝试对设备的CPU进行锁频，即保证在测试的过程中，硬件设备的CPU运行在一个恒定的频率。</p>
<p>说到这里先埋个伏笔，在chromium官方测试库中，部分测试场景在初始化测试环境时，就会将设备所有CPU的频率调到最高状态，后续我会单独以一篇博客的形式对那部分的源码进行分析。对于等不及的朋友，可以先去看下源码，源码路径为<code>pylib/perf/PerfControl.SetHighPerfMode</code>。</p>
<h2 id="查看CPU状态信息"><a href="#查看CPU状态信息" class="headerlink" title="查看CPU状态信息"></a>查看CPU状态信息</h2><p>在修改CPU的状态之前，我们需要先查看CPU的属性和状态信息，这样才能有针对性地进行正确的设置。</p>
<p>对于CPU的状态，我们通常会关注两类信息，一是整体层面的，即CPU运行的核数；二是细节层面的，即各个CPU的工作状态，包括所处工作模式、频率大小等。</p>
<p>在Android系统中，CPU相关的信息存储在<code>/sys/devices/system/cpu</code>目录的文件中，我们可以通过读取该目录下的特定文件获得当前设备的CPU状态信息，也可以通过对该目录下的特定文件进行写值，实现对CPU频率等状态信息的更改。</p>
<p>本文以<code>Nexus 5</code>（系统版本5.1.1）为例，后面的例子均以该设备为例。不同的机型和Android系统版本可能会存在一些差异，请知悉。</p>
<p>在<code>/sys/devices/system/cpu</code>目录中，文件结构如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">shell@hammerhead:/sys/devices/system/cpu $ ll</div><div class="line">drwxr-xr-x root     root              2016-01-20 01:36 cpu0</div><div class="line">drwxr-xr-x root     root              2016-01-20 21:06 cpu1</div><div class="line">drwxr-xr-x root     root              2016-01-20 21:07 cpu2</div><div class="line">drwxr-xr-x root     root              2016-01-20 21:07 cpu3</div><div class="line">-rw------- root     root         4096 1970-01-17 10:27 cpuctl</div><div class="line">drwxr-xr-x root     root              1970-01-17 10:27 cpufreq</div><div class="line">drwxr-xr-x root     root              1970-01-17 10:27 cpuidle</div><div class="line">-r--r--r-- root     root         4096 1970-01-17 10:27 kernel_max</div><div class="line">-r--r--r-- root     root         4096 1970-01-17 10:27 offline</div><div class="line">-r--r--r-- root     root         4096 1970-01-17 10:27 online</div><div class="line">-r--r--r-- root     root         4096 1970-01-17 10:27 possible</div><div class="line">drwxr-xr-x root     root              1970-01-17 10:27 power</div><div class="line">-r--r--r-- root     root         4096 1970-01-17 10:27 present</div><div class="line">-rw-r--r-- root     root         4096 1970-01-17 10:27 uevent</div></pre></td></tr></table></figure>
<h3 id="1、view-overall-cpu-info"><a href="#1、view-overall-cpu-info" class="headerlink" title="1、view overall cpu info"></a>1、view overall cpu info</h3><p>在<code>possible</code>文件中，存储的是当前设备可用的CPU，显示形式以数字的形式。例如<code>0-3</code>代表的就是当前设备总共有4个核，编号分别为0，1，2，3。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">shell@hammerhead:/sys/devices/system/cpu $ cat possible</div><div class="line">0-3</div></pre></td></tr></table></figure>
<p>在<code>online</code>文件中，存储的是当前设备正在运行的CPU。因为有时候设备不需要很高的性能，就可以将部分CPU关闭。不过需要注意的是，不管什么时候，<code>CPU0</code>始终都会处于运行状态。<code>online</code>文件的存储格式与<code>possible</code>类似，如果只有部分CPU运行，且CPU编号不连续的时候，会以逗号进行隔开；例如，<code>0,2</code>表示当前CPU0和CPU2处于运行状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">shell@hammerhead:/sys/devices/system/cpu $ cat online</div><div class="line">0,2</div></pre></td></tr></table></figure>
<p>对应的，<code>offline</code>文件标示的是当前设备处于关闭状态的CPU，这和<code>online</code>作为互补，并集刚好就是设备的所有CPU，即<code>possible</code>文件中的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">shell@hammerhead:/sys/devices/system/cpu $ cat offline</div><div class="line">1,3</div></pre></td></tr></table></figure>
<h3 id="2、view-specified-cpu-info"><a href="#2、view-specified-cpu-info" class="headerlink" title="2、view specified cpu info"></a>2、view specified cpu info</h3><p>接下来，我们要获取到特定CPU的信息，就需要进入到对应的文件夹，例如，<code>cpu0/</code>对应的就是CPU0的信息。</p>
<p>在<code>/sys/devices/system/cpu/cpu0</code>目录中，文件结构如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">shell@hammerhead:/sys/devices/system/cpu $ ll cpu0</div><div class="line">drwxr-xr-x root     root              2016-01-20 01:37 cpufreq</div><div class="line">drwxr-xr-x root     root              1970-01-17 10:27 cpuidle</div><div class="line">-r-------- root     root         4096 1970-01-17 10:27 crash_notes</div><div class="line">-rw-r--r-- root     root         4096 2016-01-20 01:36 online</div><div class="line">drwxr-xr-x root     root              1970-01-17 10:27 power</div><div class="line">drwxr-xr-x root     root              1970-01-17 10:27 rq-stats</div><div class="line">lrwxrwxrwx root     root              1970-01-17 10:27 subsystem</div><div class="line">drwxr-xr-x root     root              1970-01-17 10:27 topology</div><div class="line">-rw-r--r-- root     root         4096 1970-01-17 10:27 uevent</div></pre></td></tr></table></figure>
<p>其中，<code>online</code>文件的内容表示当前CPU是否处于运行状态，若处于运行状态，则内容为1，否则为0；这个和上面讲到的<code>/sys/devices/system/cpu/online</code>能进行对应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">shell@hammerhead:/sys/devices/system/cpu $ cat cpu0/online                     </div><div class="line">1</div></pre></td></tr></table></figure>
<p>在<code>cpu0/cpufreq/</code>目录下，存储的就是与CPU0的频率相关的信息，文件结构如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">shell@hammerhead:/sys/devices/system/cpu $ ll cpu0/cpufreq/</div><div class="line">-rw-r--r-- root     root         4096 2016-01-20 01:57 UV_mV_table</div><div class="line">-r--r--r-- root     root         4096 2016-01-20 01:57 affected_cpus</div><div class="line">-r--r--r-- root     root         4096 2016-01-20 01:57 cpu_utilization</div><div class="line">-r-------- root     root         4096 2016-01-20 01:57 cpuinfo_cur_freq</div><div class="line">-r--r--r-- root     root         4096 2016-01-20 02:00 cpuinfo_max_freq</div><div class="line">-r--r--r-- root     root         4096 2016-01-20 01:39 cpuinfo_min_freq</div><div class="line">-r--r--r-- root     root         4096 2016-01-20 01:57 cpuinfo_transition_latency</div><div class="line">-r--r--r-- root     root         4096 2016-01-20 01:57 related_cpus</div><div class="line">-r--r--r-- root     root         4096 2016-01-20 01:39 scaling_available_frequencies</div><div class="line">-r--r--r-- root     root         4096 2016-01-20 01:57 scaling_available_governors</div><div class="line">-r--r--r-- root     root         4096 2016-01-20 01:50 scaling_cur_freq</div><div class="line">-r--r--r-- root     root         4096 2016-01-20 01:57 scaling_driver</div><div class="line">-rw-r--r-- root     root         4096 2016-01-20 01:50 scaling_governor</div><div class="line">-rw-r--r-- root     root         4096 2016-01-20 08:29 scaling_max_freq</div><div class="line">-rw-r--r-- root     root         4096 2016-01-20 08:29 scaling_min_freq</div><div class="line">-rw-r--r-- root     root         4096 2016-01-20 02:52 scaling_setspeed</div></pre></td></tr></table></figure>
<p>在这个目录中，我们需要关注的文件比较多。</p>
<p>首先是<code>scaling_available_governors</code>和<code>scaling_governor</code>。这里的<code>governor</code>大家可以理解为CPU的工作模式，<code>scaling_available_governors</code>中存储了当前CPU支持的所有工作模式，而<code>scaling_governor</code>存储的是CPU当前所处的工作模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">shell@hammerhead:/sys/devices/system/cpu $ cat cpu0/cpufreq/scaling_available_governors</div><div class="line">impulse dancedance smartmax interactive conservative ondemand userspace powersave Lionheart bioshock performance</div><div class="line"></div><div class="line">shell@hammerhead:/sys/devices/system/cpu $ cat cpu0/cpufreq/scaling_governor</div><div class="line">performance</div></pre></td></tr></table></figure>
<p>可以看到，<code>Nexus 5</code>支持非常多的工作模式，这里只对几个常见的模式进行简单说明。</p>
<ul>
<li>performance：最高性能模式，即使系统负载非常低，cpu也在最高频率下运行。</li>
<li>powersave：省电模式，与performance模式相反，cpu始终在最低频率下运行。</li>
<li>ondemand：CPU频率跟随系统负载进行变化。</li>
<li>userspace：可以简单理解为自定义模式，在该模式下可以对频率进行设定。</li>
</ul>
<p>对于各种模式对应的含义和策略，在此不进行展开，大家有兴趣的可以自行搜索。</p>
<p>然后是CPU的工作频率范围，对应的文件有<code>cpuinfo_max_freq</code>、<code>cpuinfo_min_freq</code>、<code>scaling_max_freq</code>、<code>scaling_min_freq</code>。</p>
<p>以<code>cpuinfo_</code>为前缀的表示CPU硬件支持的频率范围，反映的是CPU自身的特性，与CPU的工作模式无关。而以<code>scaling_</code>为前缀的表示CPU在当前工作模式下的频率范围。</p>
<p>那么，当前CPU工作的频率是多少，我们要怎么查看呢？</p>
<p>查看<code>cpuinfo_cur_freq</code>或<code>scaling_cur_freq</code>即可。<code>cpuinfo_cur_freq</code>代表通过硬件实际上读到的频率值，而<code>scaling_cur_freq</code>则是软件当前的设置值，多数情况下这两个值是一致的，但是也有可能因为硬件的原因，有微小的差异。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">root@hammerhead:/sys/devices/system/cpu/cpu0/cpufreq # cat cpuinfo_cur_freq</div><div class="line">1574400</div><div class="line">root@hammerhead:/sys/devices/system/cpu/cpu0/cpufreq # cat scaling_cur_freq</div><div class="line">1574400</div></pre></td></tr></table></figure>
<h2 id="更改CPU状态信息"><a href="#更改CPU状态信息" class="headerlink" title="更改CPU状态信息"></a>更改CPU状态信息</h2><p>最后回到我们本文的主题，如何对CPU的频率进行设定呢？</p>
<p>这也和CPU信息查看对应，分为对CPU整体运行情况的设置，和对特定CPU工作模式的设定。</p>
<p>在此，有两点需要特别进行说明。</p>
<p>首先，对于高通的CPU，存在一个系统服务，叫作<code>mpdecision service</code>。当这个系统服务处于运行状态时，我们无法对CPU的状态信息进行更改。因此，如果我们要更改高通CPU的工作模式，第一步要做的就是终止<code>mpdecision</code>系统服务。</p>
<p>操作起来也很简单，在Android shell里面执行如下命令即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">stop mpdecision</div></pre></td></tr></table></figure>
<p>第二点需要注意的是，如果我们想要实现对特定CPU的工作状态进行设置，就必须将<code>scaling_governor</code>设置为<code>userspace</code>，只有这样，我们才能对<code>scaling_setspeed</code>进行设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">root@hammerhead:/sys/devices/system/cpu/cpu0/cpufreq # cat scaling_setspeed</div><div class="line">&lt;unsupported&gt;</div><div class="line"></div><div class="line">root@hammerhead:/sys/devices/system/cpu/cpu0/cpufreq # echo userspace &gt; scaling_governor</div><div class="line">root@hammerhead:/sys/devices/system/cpu/cpu0/cpufreq # cat scaling_setspeed    </div><div class="line">1574400</div></pre></td></tr></table></figure>
<h3 id="1、set-overall-cpu-info"><a href="#1、set-overall-cpu-info" class="headerlink" title="1、set overall cpu info"></a>1、set overall cpu info</h3><p>从宏观层面，我们可以对CPU运行的核数进行设置，即可实现对特定CPU的开启和关闭。当然，我们在前面已经说过，CPU0始终会处于运行状态，因此我们无法将CPU0进行关闭。</p>
<p>设置的方式很简单，就是往<code>/sys/devices/system/cpu/cpu[i]/online</code>文件中写值即可，写1时开启指定CPU，写0时关闭指定CPU。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># turn off cpu1</div><div class="line">root@hammerhead:/sys/devices/system/cpu/cpu1 # echo 0 &gt; online</div><div class="line">root@hammerhead:/sys/devices/system/cpu/cpu1 # cat online</div><div class="line">0</div></pre></td></tr></table></figure>
<h3 id="2、set-specified-cpu-info"><a href="#2、set-specified-cpu-info" class="headerlink" title="2、set specified cpu info"></a>2、set specified cpu info</h3><p>在对特定CPU的频率进行设定前，我们需要知道的是，CPU并不能工作在任意频率下，我们只能将CPU的频率设定为它支持的数值。</p>
<p>通过查看<code>scaling_available_frequencies</code>，我们可以获得当前CPU支持的频率值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@hammerhead:/sys/devices/system/cpu/cpu0/cpufreq # cat scaling_available_frequencies</div><div class="line">300000 422400 652800 729600 883200 960000 1036800 1190400 1267200 1497600 1574400 1728000 1958400 2265600</div></pre></td></tr></table></figure>
<p>接下来，我们就可以对CPU的工作频率进行设置了。</p>
<p>如何进行设置呢？刚开始的时候，我觉得将特定的频率值写入<code>scaling_setspeed</code>或<code>scaling_cur_freq</code>就可以了，通过Google搜索得到的方法中也是这种方式。</p>
<p>但经过尝试，发现并不可行。为什么会这样？我也还没有找到答案，希望知道原因的朋友能告诉我。</p>
<p>最后经过尝试，发现通过同时将<code>scaling_max_freq</code>和<code>scaling_min_freq</code>设置为目标频率值，就可以成功地对CPU频率完成设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># before setting</div><div class="line">shell@hammerhead:/sys/devices/system/cpu/cpu0/cpufreq $ cat scaling_cur_freq</div><div class="line">1574400</div><div class="line"></div><div class="line"># setting</div><div class="line">shell@hammerhead:/sys/devices/system/cpu/cpu0/cpufreq $ echo 1728000 &gt; scaling_min_freq</div><div class="line">shell@hammerhead:/sys/devices/system/cpu/cpu0/cpufreq $ echo 1728000 &gt; scaling_max_freq</div><div class="line"></div><div class="line"># after setting</div><div class="line">shell@hammerhead:/sys/devices/system/cpu/cpu0/cpufreq $ cat scaling_cur_freq</div><div class="line">1728000</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对Android设备CPU的状态查看方法和锁频（lock frequency）方法进行详细介绍。这有什么用？作为测试工程师，你值得了解。&lt;/p&gt;
&lt;h2 id=&quot;CPU频率&quot;&gt;&lt;a href=&quot;#CPU频率&quot; class=&quot;headerlink&quot; title=&quot;CPU频
    
    </summary>
    
    
      <category term="Android" scheme="http://debugtalk.com/tags/Android/"/>
    
      <category term="CPU" scheme="http://debugtalk.com/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>Android App持续集成性能测试：使用Python实现UI自动化</title>
    <link href="http://debugtalk.com/post/Android-performance-test-UI-Automation-with-Python/"/>
    <id>http://debugtalk.com/post/Android-performance-test-UI-Automation-with-Python/</id>
    <published>2016-04-16T16:00:00.000Z</published>
    <updated>2016-07-23T07:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在进行Android App持续集成性能测试的时候，需要自动化实现UI层面的一些操作，常见的几种场景包括：</p>
<ul>
<li>测试帧率时，需要模拟滑屏、拖拽操作；</li>
<li>初次安装app后启动应用时，需要点击按钮跳过协议页面；</li>
<li>从<code>Android M</code>(6.0)开始，首次启动应用时会进行系统权限校验，需要勾选checkbox以及点击按钮；</li>
<li>模拟点击按钮登录用户账号；</li>
</ul>
<p>这些场景虽然看上去互不相关，但是从测试的角度，UI层面的操作应该都可以归为两类：控件定位和执行动作。</p>
<p>本文将从测试的角度出发，介绍Android UI实现自动化测试的基本方法，并着重讲解通过Python操作Android UI的一般性流程。后续，我会在单独的博客文章中介绍UI操作在Android App持续集成性能测试中的应用。</p>
<h2 id="先说uiautomator"><a href="#先说uiautomator" class="headerlink" title="先说uiautomator"></a>先说uiautomator</h2><p>要对Android的UI实现自动化操作，首先想到的就是Google官方的<code>UI Automator</code>，通过这个工具，可以很好地实现Android UI自动化。</p>
<p><code>UI Automator</code>是一个从Android 4.3 (API level 18) 引入的测试框架，它提供了一套丰富的API，可以在不依赖于目标app内部实现机制的基础上，方便地创建自动化测试用例，实现用户对Android UI各种界面交互操作的模拟。</p>
<p>对于<code>UI Automator</code>的使用介绍，我从创建测试用例和执行测试两部分进行。</p>
<p>首先是创建测试用例，流程大致如下：</p>
<ul>
<li>采用JUnit Library创建Java Project</li>
<li>将<code>Android-sdk</code>中的<code>android.jar</code>和<code>uiautomator.jar</code>添加进项目</li>
<li>使用<code>UI Automator</code>提供的API编写测试用例，实现对UI界面操作的定制场景，例如点击按钮、滑动屏幕等</li>
<li>将项目编译生成jar文件，例如memorytest.jar</li>
</ul>
<p>创建好了测试用例，那要怎样执行呢？</p>
<p>从Android 4.3开始，系统中就自带了<code>uiautomator</code>命令，命令的路径为<code>/system/bin/uiautomator</code>。</p>
<p>由于<code>uiautomator</code>命令是运行在Android设备中的，因此需先要将编译好的jar文件push到Android设备中，导入目录为<code>/data/local/tmp/</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">➜  adb push memorytest.jar /data/local/tmp/</div></pre></td></tr></table></figure>
<p>完成以上准备工作后，就可以在Android的Terminal中执行了<code>uiautomator</code>命令了。</p>
<p>详细的<code>uiautomator</code>命令用法可参考官方文档，这里只列出最常用的一种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">➜  adb shell</div><div class="line">shell@hammerhead:/ $ uiautomator runtest memorytest.jar -c com.uc.util.TestCases<span class="comment">#slideScreen -e pkgName com.UCMobile</span></div></pre></td></tr></table></figure>
<p>在如上示例中，<code>memorytest.jar</code>是我们之前编译好的测试用例jar文件名，<code>com.uc.util.TestCases#slideScreen</code>是Java工程中的类名和方法名，<code>-e</code>后面是传入测试类的<code>name-value</code>参数。</p>
<p>这里就不再对<code>UI Automator</code>进行过多介绍，后续我会再针对<code>UI Automator</code>单独写一篇更加详细的教程。</p>
<h2 id="Python调用uiautomator"><a href="#Python调用uiautomator" class="headerlink" title="Python调用uiautomator"></a>Python调用uiautomator</h2><p>通常，我们的持续集成性能测试代码是采用Python编写的，那如何通过Python调用uiautomator呢？</p>
<p>如果沿用上面介绍的流程，Python调用uiautomator实现自动化测试应该也会采用同样的思路：</p>
<p>首先，需要在Java Project使用<code>UI Automator API</code>编写UI测试场景，编译生成jar文件，并将这个文件导入到Python项目中。</p>
<p>然后，在Python测试代码中，调用<code>uiautomator</code>命令前需要先将jar文件push到Android设备。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jar_file_path = os.path.join(_project_root_path, <span class="string">"resource/jar/memorytest.jar"</span>)</div><div class="line">cmdexec.push(jar_file_path, <span class="string">'/data/local/tmp/'</span>)</div></pre></td></tr></table></figure>
<p>接下来，就可以在Python中组装测试命令，并将命令传到Android设备中进行执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cmd = <span class="string">"uiautomator runtest memorytest.jar -c com.uc.util.TestCases#slideScreen -e pkgName com.UCMobile"</span></div><div class="line">cmdexec.sendShellCommand(cmd, timeout_time=<span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<p>需要说明的是，上面代码中的<code>cmdexec</code>是一个封装类的实例，主要实现的是通过adb与Android设备进行交互，例如push/pull文件、执行Android shell命令等。</p>
<p>经过这么一个流程，可能大家都会感觉到实现起来太过复杂。特别地，如果需要增加一个测试场景，就又要到Java项目中添加测试代码，重新编译为jar文件，并将新的jar文件添加到Python项目中，或者替换原有jar文件。这还不算完，同样地，在Python项目中也需要针对新增的测试场景进行相应的编码。</p>
<p>难道就没有更便捷的方式么？</p>
<p>幸运的是，之前已经有人针对这个痛点填了坑，并在GitHub上进行了开源，项目名称是<code>xiaocong/uiautomator</code>（为了便于与Google官方的uiautomator进行区分，后面统一采用pyuiautomator进行描述）。它实现的功能很明确，从项目简介就一目了然。</p>
<blockquote>
<p>Python wrapper of Android uiautomator test tool.</p>
</blockquote>
<p>该工具以<code>Python package</code>的形式存在，可通过<code>pip</code>在测试机（PC）上进行安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install uiautomator</div></pre></td></tr></table></figure>
<p>安装完毕后，无需在Android设备上安装任何东西，只要设备通过adb与主机相连，就可以在主机中通过Python操作Android设备的UI控件。</p>
<p>如下是简单的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> uiautomator <span class="keyword">import</span> device <span class="keyword">as</span> d</div><div class="line"></div><div class="line"><span class="comment"># Turn on screen</span></div><div class="line">d.screen.on()</div><div class="line"></div><div class="line"><span class="comment"># press back key</span></div><div class="line">d.press.back()</div><div class="line"></div><div class="line"><span class="comment"># click (x, y) on screen</span></div><div class="line">d.click(x, y)</div><div class="line"></div><div class="line"><span class="comment"># check unchecked checkbox</span></div><div class="line">checkbox = d(className=<span class="string">'android.widget.CheckBox'</span>, checked=<span class="string">'false'</span>)</div><div class="line">checkbox.click()</div><div class="line"></div><div class="line"><span class="comment"># click button with text 'Next'</span></div><div class="line">d(text=<span class="string">"Clock"</span>).click()</div><div class="line">button = d(className=<span class="string">'android.widget.Button'</span>, text=<span class="string">'Next'</span>)</div><div class="line">button.click()</div><div class="line"></div><div class="line"><span class="comment"># swipe from (sx, sy) to (ex, ey)</span></div><div class="line">d.swipe(sx, sy, ex, ey)</div></pre></td></tr></table></figure>
<p>更详细的使用方法可参考<a href="https://github.com/xiaocong/uiautomator" target="_blank" rel="external">项目文档</a>。</p>
<p>通过这种方式，我们就可以极大地简化Python操作UI控件的方式，不用再对照着<code>UI Automator API</code>使用Java编写测试用例，也不用再反复编译jar文件，省去了同一个测试场景需要维护两套代码的麻烦，整个过程也更加Pythonic。</p>
<p>当然，<code>pyuiautomator</code>也并非完美，毕竟它不是Google官方维护的，从我实际使用的经历来看，有时候也会存在一些问题。这里先不展开，后续会单独写一篇博客。不过，总的来说，<code>pyuiautomator</code>还是非常值得使用的，它的确可以大大简化测试工作量。</p>
<p>现在继续本文的主题，我们怎么采用<code>pyuiautomator</code>来进行UI控件操作呢？</p>
<p>其实从上面的示例代码中就可以看到，UI控件的操作分为两步，首先是对目标控件进行定位，然后是对定位的控件执行动作。</p>
<h2 id="定位控件"><a href="#定位控件" class="headerlink" title="定位控件"></a>定位控件</h2><p>在UI中，每个控件都有许多属性，例如<code>class</code>、<code>text</code>、<code>index</code>等等。我们要想对某一个控件进行操作，必然需要先对目标控件进行选择。</p>
<p>在上面的<code>pyuiautomator</code>用法示例中，已经包含了控件选择的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">checkbox = d(className=<span class="string">'android.widget.CheckBox'</span>, checked=<span class="string">'false'</span>)</div><div class="line">button = d(className=<span class="string">'android.widget.Button'</span>, text=<span class="string">'Next'</span>)</div></pre></td></tr></table></figure>
<p>在这两行代码中，分别实现了对checkbox和button的选择。基本原则就是，通过指定的控件属性，可以唯一确定目标控件。</p>
<p>那么，我们怎么知道目标控件有哪些属性，以及对应的属性值是什么呢？</p>
<p>Google官方提供了两个工具，<code>hierarchyviewer</code>和<code>uiautomatorviewer</code>，这两个工具都位于<code>&lt;android-sdk&gt;/tools/</code>目录下。关于这两个工具的区别及其各自的特点，本文不进行详细介绍，我们当前只需要知道，在查看控件属性方面，这两个工具实现的功能完全相同，界面也完全相同，我们任选其一即可。</p>
<p>{: .center}<br><img src="/images/uiautomatorviewer.png" alt="uiautomatorviewer"></p>
<p>通过这个工具，我们可以查看到当前设备屏幕中的UI元素信息：</p>
<ul>
<li>当前Android设备屏幕中显示的UI元素的详细属性信息</li>
<li>当前Android设备屏幕中所有UI元素的层级关系结构</li>
</ul>
<p>需要强调的是，工具每执行一次dump，获取到的UI信息仅限于当前屏幕中前端（foreground）显示的内容。</p>
<p>获得UI元素的信息后，由于UI控件是以树形结构进行存储，而且每个控件都存在index属性值，因此，理论上讲，通过层级结构和index属性就能唯一指定任意UI控件。</p>
<p>然而，这并不是最佳实践。因为通常情况下，UI布局的树形结构层级较多，通过层级关系进行指定时会造成书写极为复杂，而且从代码中很难一眼看出指定的是哪个控件。不信？看下这个例子就能体会了。如下代码对应的就是上图中红色方框的控件，可以看出，要是寻找每个控件都要从顶级节点开始，要将根节点到目标控件的路径找出来，这也是一个很大的工作量，而且很容易出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">d(className=&apos;android.widget.FrameLayout&apos;)</div><div class="line">  .child(className=&apos;android.widget.LinearLayout&apos;)</div><div class="line">  .child(className=&apos;android.widget.FrameLayout&apos;)</div><div class="line">  .child(className=&apos;android.widget.FrameLayout&apos;)</div><div class="line">  .child(className=&apos;android.widget.FrameLayout&apos;)</div><div class="line">  .child(className=&apos;android.widget.FrameLayout&apos;)</div><div class="line">  .child(className=&apos;android.widget.FrameLayout&apos;)</div><div class="line">  .child(className=&apos;android.view.View&apos;)</div><div class="line">  .child(className=&apos;android.widget.FrameLayout&apos;)</div><div class="line">  .child(className=&apos;android.widget.FrameLayout&apos;)</div><div class="line">  .child(className=&apos;android.view.View&apos;)</div><div class="line">  .child(className=&apos;android.widget.FrameLayout&apos;)</div><div class="line">  .child(className=&apos;android.widget.TextView&apos;)</div></pre></td></tr></table></figure>
<p>在实际应用中，我们更多地是采用控件的属性信息来定位控件，一般情况下，采用属性值<code>text</code>就能唯一确定目标控件了。例如同样是对上图中的红色方框进行定位，如下代码就足够了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d(text=&apos;UC头条有新消息，点击刷新&apos;)</div></pre></td></tr></table></figure>
<p>不过，经常会出现目标控件的<code>text</code>属性值为空的情况，这个时候我们一般就会采用<code>class</code>属性和部分层级关系组合的方式。同样是上图中的红色方框，我们也可以使用如下方式进行定位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d(className=&apos;android.widget.FrameLayout&apos;).child(className=&apos;android.widget.TextView&apos;)</div></pre></td></tr></table></figure>
<p>可以看出，同一个控件，我们可以采用多种方式进行定位。具体选择何种定位方式，可以参考如下准则：</p>
<ul>
<li>定位方式应保证定位准确</li>
<li>定位方式应尽可能简洁</li>
<li>定位方式应尽可能稳定，即使屏幕界面出现变化，定位方式也不会失效</li>
</ul>
<p>这里说到了定位方式的准确性，那要如何进行验证呢？技巧是，采用<code>.count</code>和<code>.info</code>属性值即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d(text=<span class="string">'UC头条有新消息，点击刷新'</span>).count</div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d(text=<span class="string">'UC头条有新消息，点击刷新'</span>).info</div><div class="line">&#123;<span class="string">u'contentDescription'</span>: <span class="keyword">None</span>, <span class="string">u'checked'</span>: <span class="keyword">False</span>, <span class="string">u'clickable'</span>: <span class="keyword">True</span>, <span class="string">u'scrollable'</span>: <span class="keyword">False</span>, <span class="string">u'text'</span>: <span class="string">u'UC\u5934\u6761\u6709\u65b0\u6d88\u606f\uff0c\u70b9\u51fb\u5237\u65b0'</span>, <span class="string">u'packageName'</span>: <span class="string">u'com.UCMobile.projectscn1098RHEAD'</span>, <span class="string">u'selected'</span>: <span class="keyword">False</span>, <span class="string">u'enabled'</span>: <span class="keyword">True</span>, <span class="string">u'bounds'</span>: &#123;<span class="string">u'top'</span>: <span class="number">1064</span>, <span class="string">u'left'</span>: <span class="number">42</span>, <span class="string">u'right'</span>: <span class="number">1038</span>, <span class="string">u'bottom'</span>: <span class="number">1136</span>&#125;, <span class="string">u'className'</span>: <span class="string">u'android.widget.TextView'</span>, <span class="string">u'focusable'</span>: <span class="keyword">False</span>, <span class="string">u'focused'</span>: <span class="keyword">False</span>, <span class="string">u'checkable'</span>: <span class="keyword">False</span>, <span class="string">u'resourceName'</span>: <span class="keyword">None</span>, <span class="string">u'longClickable'</span>: <span class="keyword">False</span>, <span class="string">u'visibleBounds'</span>: &#123;<span class="string">u'top'</span>: <span class="number">1064</span>, <span class="string">u'left'</span>: <span class="number">42</span>, <span class="string">u'right'</span>: <span class="number">1038</span>, <span class="string">u'bottom'</span>: <span class="number">1136</span>&#125;, <span class="string">u'childCount'</span>: <span class="number">0</span>&#125;</div></pre></td></tr></table></figure>
<p>当<code>.count</code>属性值为1，<code>.info</code>属性值的内容与目标控件的属性值一致时，就可以确定我们采用的定位方式是准确的。</p>
<h2 id="控件操作"><a href="#控件操作" class="headerlink" title="控件操作"></a>控件操作</h2><p>定位到具体的控件后，操作就比较容易了。</p>
<p>在<code>pyuiautomator</code>中，对<code>UI Automator</code>的UI操作动作进行了封装，常用的操作动作有：</p>
<ul>
<li>.click()</li>
<li>.long_click()</li>
<li>.swipe</li>
<li>.drag</li>
</ul>
<p>更多的操作可根据我们测试场景的实际需求，查询<code>pyuiautomator</code>文档找到合适的方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到这里，相信大家对Android UI自动化测试已经有了基本的认识。由于篇幅关系，我没有将所有内容都包含进来，而是打算后续分多个专题以单独博文的形式进行展开（不知不觉就给自己埋下了坑^_^）。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="http://developer.android.com/tools/testing-support-library/index.html#UIAutomator" target="_blank" rel="external">http://developer.android.com/tools/testing-support-library/index.html#UIAutomator</a></li>
<li><a href="https://github.com/xiaocong/uiautomator" target="_blank" rel="external">https://github.com/xiaocong/uiautomator</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行Android App持续集成性能测试的时候，需要自动化实现UI层面的一些操作，常见的几种场景包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;测试帧率时，需要模拟滑屏、拖拽操作；&lt;/li&gt;
&lt;li&gt;初次安装app后启动应用时，需要点击按钮跳过协议页面；&lt;/li&gt;
&lt;li&gt;从&lt;cod
    
    </summary>
    
    
      <category term="Android" scheme="http://debugtalk.com/tags/Android/"/>
    
      <category term="Python" scheme="http://debugtalk.com/tags/Python/"/>
    
      <category term="UI" scheme="http://debugtalk.com/tags/UI/"/>
    
      <category term="AutomationTest" scheme="http://debugtalk.com/tags/AutomationTest/"/>
    
  </entry>
  
  <entry>
    <title>Python的函数式编程--从入门到⎡放弃⎦</title>
    <link href="http://debugtalk.com/post/python-functional-programming-getting-started/"/>
    <id>http://debugtalk.com/post/python-functional-programming-getting-started/</id>
    <published>2016-04-07T16:00:00.000Z</published>
    <updated>2016-07-23T07:30:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>很早以前就听说过了函数式编程，印象中是一种很晦涩难懂的编程模式，但却一直没有去进行了解。</p>
<p>恰好这周组内的周会轮到我主持，一时也没想到要分享什么。灵光一闪，就选定函数式编程这个主题吧，反正组里的同事都没有学过，只需要讲解入门方面的知识就好，也正好可以借这个机会逼迫自己去学习下这种新的编程方式。</p>
<p>经过初步了解，发现支持函数式编程的语言挺多的，除了像Lisp、Scheme、Haskell、Erlang这样专用的函数式编程语言，我们常用的好多通用型编程语言（如Java、Python、Ruby、Javascript等）都支持函数式编程模式。考虑了下实际情况，最终还是选择Python作为函数式编程的入门语言，因为组内同事都熟悉Python，以此作为切入点不会产生太大困难。</p>
<p>经过查询资料和初步学习，对函数式编程有了些概念，经过整理，便形成了分享PPT。</p>
<p>以下便是这次分享的内容。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>通常，我们在新学习一门技术或者编程语言的时候，通常都会先从相关概念和特性入手。对于新接触函数式编程的人来说，可能会想知道如下几点：</p>
<ul>
<li>什么是函数式编程？</li>
<li>函数式编程的特点？</li>
<li>函数式编程的用途？</li>
<li>函数式编程相比于命令式编程和面向对象编程的优缺点？</li>
</ul>
<p>但是我这次分享却没有按照这个思路，因为我感觉在一开始就向听众灌输太多概念性的东西，反倒会让听众感到迷糊。因为经过查询资料发现，对于什么是函数化编程，很难能有一个协调一致的定义。而且由于我也是新接触，自身的理解可能会存在较大的偏差。</p>
<p>因此，我决定分享内容尽量从大家熟悉的命令式编程切入，通过大量实例来向听众展现函数式编程思维方式的不同之处。在这之后，再回过头看这几个问题，相信听众应该都会有更深刻的理解。</p>
<p>考虑到实际情况，本次分享希望能达成的目标是：</p>
<ul>
<li>了解函数式编程与命令式编程的主要区别</li>
<li>掌握Python语言函数式编程的基本函数和算子</li>
<li>会将简单的命令式编程语句转换为函数式编程</li>
</ul>
<h2 id="命令式编程-amp-函数式编程"><a href="#命令式编程-amp-函数式编程" class="headerlink" title="命令式编程 &amp; 函数式编程"></a>命令式编程 &amp; 函数式编程</h2><p>首先从大家熟悉的命令式编程开始，我们先回顾下平时在写代码时主要的情景。</p>
<p>其实，不管我们的业务代码有多复杂，都离不开以下几类操作：</p>
<ul>
<li>函数定义：def</li>
<li>条件控制：if, elif, else</li>
<li>循环控制：for, break, continue, while</li>
</ul>
<p>当然，这只是部分操作类型，除此之外还应该有类和模块、异常处理等等。但考虑到是入门，我们就先只关注上面这三种最常见的操作。</p>
<p>对应地，函数式编程也有自己的关键字。在Python语言中，用于函数式编程的主要由3个基本函数和1个算子。</p>
<ul>
<li>基本函数：map()、reduce()、filter()</li>
<li>算子(operator)：lambda</li>
</ul>
<p>令人惊讶的是，仅仅采用这几个函数和算子就基本上可以实现任意Python程序。</p>
<p>当然，能实现是一回事儿，实际编码时是否这么写又是另外一回事儿。估计要真只采用这几个基本单元来写所有代码的话，不管是在表达上还是在阅读上应该都挺别扭的。不过，尝试采用这几个基本单元来替代上述的函数定义、条件控制、循环控制等操作，对理解函数式编程如何通过函数和递归表达流程控制应该会很有帮助。</p>
<p>在开始尝试将命令式编程转换为函数式编程之前，我们还是需要先熟悉下这几个基本单元。</p>
<h2 id="Python函数式编程的基本单元"><a href="#Python函数式编程的基本单元" class="headerlink" title="Python函数式编程的基本单元"></a>Python函数式编程的基本单元</h2><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>lambda这个关键词在很多语言中都存在。简单地说，它可以实现函数创建的功能。</p>
<p>如下便是lambda的两种使用方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func1 = <span class="keyword">lambda</span> : &lt;expression()&gt;</div><div class="line">func2 = <span class="keyword">lambda</span> x : &lt;expression(x)&gt;</div><div class="line">func3 = <span class="keyword">lambda</span> x,y : &lt;expression(x,y)&gt;</div></pre></td></tr></table></figure>
<p>在第一条语句中，采用lambda创建了一个无参的函数func1。这和下面采用def创建函数的效果是相同的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></div><div class="line">    &lt;expression()&gt;</div></pre></td></tr></table></figure>
<p>在第二条和第三条语句中，分别采用lambda创建了需要传入1个参数的函数func2，以及传入2个参数的函数func3。这和下面采用<code>def</code>创建函数的效果是相同的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(x)</span>:</span></div><div class="line">    &lt;expression(x)&gt;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(x,y)</span>:</span></div><div class="line">    &lt;expression(x,y)&gt;</div></pre></td></tr></table></figure>
<p>需要注意的是，调用func1的时候，虽然不需要传入参数，但是必须要带有括号<code>()</code>，否则返回的只是函数的定义，而非函数执行的结果。这个和在ruby中调用无参函数时有所不同，希望ruby程序员引起注意。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>func = <span class="keyword">lambda</span> : <span class="number">123</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>func</div><div class="line">&lt;function &lt;<span class="keyword">lambda</span>&gt; at <span class="number">0x100f4e1b8</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>func()</div><div class="line"><span class="number">123</span></div></pre></td></tr></table></figure>
<p>另外，虽然在上面例子中都将lambda创建的函数赋值给了一个函数名，但这并不是必须的。从下面的例子中大家可以看到，很多时候我们都是直接调用lambda创建的函数，而并没有命名一个函数，这也是我们常听说的匿名函数的由来。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><code>map()</code>函数的常见调用形式如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map(func, iterable)</div></pre></td></tr></table></figure>
<p><code>map()</code>需要两个必填参数，第一个参数是一个函数名，第二个参数是一个可迭代的对象，如列表、元组等。</p>
<p><code>map()</code>实现的功能很简单，就是将第二个参数（iterable）中的每一个元素分别传给第一个参数（func），依次执行函数得到结果，并将结果组成一个新的<code>list</code>对象后进行返回。返回结果永远都是一个<code>list</code>。</p>
<p>简单示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>double_func = <span class="keyword">lambda</span> s : s * <span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>map(double_func, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</div><div class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</div></pre></td></tr></table></figure>
<p>除了传入一个可迭代对象这种常见的模式外，<code>map()</code>还支持传入多个可迭代对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map(func, iterable1, iterable2)</div></pre></td></tr></table></figure>
<p>在传入多个可迭代对象的情况下，<code>map()</code>会依次从所有可迭代对象中依次取一个元素，组成一个元组列表，然后将元组依次传给func；若可迭代对象的长度不一致，则会以None进行补上。</p>
<p>通过以下示例应该就比较容易理解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>plus = <span class="keyword">lambda</span> x,y : (x <span class="keyword">or</span> <span class="number">0</span>) + (y <span class="keyword">or</span> <span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>map(plus, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</div><div class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>map(plus, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</div><div class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>map(plus, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</div><div class="line">[<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">7</span>]</div></pre></td></tr></table></figure>
<p>在上面的例子中，之所以采用<code>x or 0</code>的形式，是为了防止<code>None + int</code>出现异常。</p>
<p>需要注意的是，可迭代对象的个数应该与func的参数个数一致，否则就会出现异常，因为传参个数与函数参数个数不一致了，这个应该比较好理解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>plus = <span class="keyword">lambda</span> x,y : x + y</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>map(plus, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">TypeError: &lt;<span class="keyword">lambda</span>&gt;() takes exactly <span class="number">2</span> arguments (<span class="number">1</span> given)</div></pre></td></tr></table></figure>
<p>另外，<code>map()</code>还存在一种特殊情况，就是func为None。这个时候，<code>map()</code>仍然是从所有可迭代对象中依次取一个元素，组成一个元组列表，然后将这个元组列表作为结果进行返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">None</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">None</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</div><div class="line">[(<span class="number">1</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">6</span>), (<span class="number">3</span>, <span class="number">7</span>), (<span class="number">4</span>, <span class="number">8</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">None</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])</div><div class="line">[(<span class="number">1</span>, <span class="number">5</span>), (<span class="number">2</span>, <span class="number">6</span>), (<span class="number">3</span>, <span class="number">7</span>), (<span class="number">4</span>, <span class="keyword">None</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>map(<span class="keyword">None</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">11</span>,<span class="number">12</span>])</div><div class="line">[(<span class="number">1</span>, <span class="number">6</span>, <span class="number">11</span>), (<span class="number">2</span>, <span class="number">7</span>, <span class="number">12</span>), (<span class="number">3</span>, <span class="number">8</span>, <span class="keyword">None</span>), (<span class="number">4</span>, <span class="number">9</span>, <span class="keyword">None</span>)]</div></pre></td></tr></table></figure>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p><code>reduce()</code>函数的调用形式如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reduce(func, iterable[, initializer])</div></pre></td></tr></table></figure>
<p><code>reduce()</code>函数的功能是对可迭代对象（iterable）中的元素从左到右进行累计运算，最终得到一个数值。第三个参数initializer是初始数值，可以空置，空置为None时就从可迭代对象（iterable）的第二个元素开始，并将第一个元素作为之前的结果。</p>
<p>文字描述可能不大清楚，看下<code>reduce()</code>的源码应该就比较清晰了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span><span class="params">(function, iterable, initializer=None)</span>:</span></div><div class="line">    it = iter(iterable)</div><div class="line">    <span class="keyword">if</span> initializer <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            initializer = next(it)</div><div class="line">        <span class="keyword">except</span> StopIteration:</div><div class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'reduce() of empty sequence with no initial value'</span>)</div><div class="line">    accum_value = initializer</div><div class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> it:</div><div class="line">        accum_value = function(accum_value, x)</div><div class="line">    <span class="keyword">return</span> accum_value</div></pre></td></tr></table></figure>
<p>再加上如下示例，对<code>reduce()</code>的功能应该就能掌握了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>plus = <span class="keyword">lambda</span> x, y : x + y</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(plus, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</div><div class="line"><span class="number">15</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(plus, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">10</span>)</div><div class="line"><span class="number">25</span></div></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p><code>filter()</code>函数的调用形式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">filter(func, iterable)</div></pre></td></tr></table></figure>
<p><code>filter()</code>有且仅有两个参数，第一个参数是一个函数名，第二个参数是一个可迭代的对象，如列表、元组等。</p>
<p><code>filter()</code>函数的调用形式与<code>map()</code>比较相近，都是将第二个参数（iterable）中的每一个元素分别传给第一个参数（func），依次执行函数得到结果；差异在于，<code>filter()</code>会判断每次执行结果的<code>bool</code>值，并只将<code>bool</code>值为<code>true</code>的筛选出来，组成一个新的列表并进行返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>mode2 = <span class="keyword">lambda</span> x : x % <span class="number">2</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>filter(mode2, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>])</div><div class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</div></pre></td></tr></table></figure>
<p>以上便是Python函数式编程基本单元的核心内容。</p>
<p>接下来，我们就开始尝试采用新学习到的基本单元对命令式编程中的<code>条件控制</code>和<code>循环控制</code>进行转换。</p>
<h2 id="替换条件控制语句"><a href="#替换条件控制语句" class="headerlink" title="替换条件控制语句"></a>替换条件控制语句</h2><p>在对<code>条件控制</code>进行替换之前，我们先来回顾下Python中对布尔表达式求值时进行的“短路”处理。</p>
<p>什么叫“短路”处理？简单地讲，就是如下两点：</p>
<ul>
<li>在<code>f(x) and g(y)</code>中，当<code>f(x)</code>为<code>false</code>时，不会再执行<code>g(y)</code>，直接返回<code>false</code></li>
<li>在<code>f(x) or g(y)</code>中，当<code>f(x)</code>为<code>true</code>时，不会再执行<code>g(y)</code>，直接返回<code>true</code></li>
</ul>
<p>结论是显然易现的，就不再过多解释。</p>
<p>那么，对应到条件控制语句，我们不难理解，如下条件控制语句和表达式是等价的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># flow control statement</span></div><div class="line"><span class="keyword">if</span> &lt;cond1&gt;:   func1()</div><div class="line"><span class="keyword">elif</span> &lt;cond2&gt;: func2()</div><div class="line"><span class="keyword">else</span>:         func3()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Equivalent "short circuit" expression</span></div><div class="line">(&lt;cond1&gt; <span class="keyword">and</span> func1()) <span class="keyword">or</span> (&lt;cond2&gt; <span class="keyword">and</span> func2()) <span class="keyword">or</span> (func3())</div></pre></td></tr></table></figure>
<p>通过这个等价替换，我们就去除掉了<code>if/elif/else</code>关键词，将条件控制语句转换为一个表达式。那这个表达式和函数式编程有什么关系呢？</p>
<p>这时我们回顾上面讲过的<code>lambda</code>，会发现<code>lambda</code>算子返回的就是一个表达式。</p>
<p>基于这一点，我们就可以采用<code>lambda</code>创建如下函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>pr = <span class="keyword">lambda</span> s:s</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print_num = <span class="keyword">lambda</span> x: (x==<span class="number">1</span> <span class="keyword">and</span> pr(<span class="string">"one"</span>)) \</div><div class="line">....                  <span class="keyword">or</span> (x==<span class="number">2</span> <span class="keyword">and</span> pr(<span class="string">"two"</span>)) \</div><div class="line">....                  <span class="keyword">or</span> (pr(<span class="string">"other"</span>))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print_num(<span class="number">1</span>)</div><div class="line"><span class="string">'one'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print_num(<span class="number">2</span>)</div><div class="line"><span class="string">'two'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print_num(<span class="number">3</span>)</div><div class="line"><span class="string">'other'</span></div></pre></td></tr></table></figure>
<p>通过函数调用的结果可以看到，以上函数实现的功能与之前的条件控制语句实现的功能完全相同。</p>
<p>到这里，我们就实现了命令式条件控制语句向函数式语句的转换。并且这个转换的方法是通用的，所有条件控制语句都可以采用这种方式转换为函数式语句。</p>
<h2 id="替换循环控制语句"><a href="#替换循环控制语句" class="headerlink" title="替换循环控制语句"></a>替换循环控制语句</h2><p>接下来我们再看<code>循环控制</code>语句的转换。在Python中，循环控制是通过<code>for</code>和<code>while</code>这两种方式实现的。</p>
<h3 id="替换for循环"><a href="#替换for循环" class="headerlink" title="替换for循环"></a>替换for循环</h3><p><code>for</code>循环语句的替换十分简单，采用<code>map()</code>函数就能轻松实现。这主要是因为<code>for</code>语句和<code>map()</code>原理相同，都是对可迭代对象里面的每一个元素进行操作，因此转换过程比较自然。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># statement-based for loop</span></div><div class="line"><span class="keyword">for</span> e <span class="keyword">in</span> lst:  func(e)</div><div class="line"></div><div class="line"><span class="comment"># Equivalent map()-based loop</span></div><div class="line">map(func, lst)</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>square = <span class="keyword">lambda</span> x : x * x</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]: square(x)</div><div class="line">...</div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">9</span></div><div class="line"><span class="number">16</span></div><div class="line"><span class="number">25</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>map(square, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</div><div class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</div></pre></td></tr></table></figure>
<h3 id="替换while循环"><a href="#替换while循环" class="headerlink" title="替换while循环"></a>替换while循环</h3><p><code>while</code>循环语句的替换相比而言就复杂了许多。</p>
<p>下面分别是<code>while</code>循环语句及其对应的函数式风格的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># statement-based while loop</span></div><div class="line"><span class="keyword">while</span> &lt;condition&gt;:</div><div class="line">    &lt;pre-suite&gt;</div><div class="line">    <span class="keyword">if</span> &lt;break_condition&gt;:</div><div class="line">        <span class="keyword">break</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        &lt;suite&gt;</div><div class="line"></div><div class="line"><span class="comment"># Equivalent FP-style recursive while loop</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">while_block</span><span class="params">()</span>:</span></div><div class="line">    &lt;pre-suite&gt;</div><div class="line">    <span class="keyword">if</span> &lt;break_condition&gt;:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        &lt;suite&gt;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span></div><div class="line"> </div><div class="line">while_FP = <span class="keyword">lambda</span>: &lt;condition&gt; <span class="keyword">and</span> (while_block() <span class="keyword">or</span> while_FP())</div><div class="line">while_FP()</div></pre></td></tr></table></figure>
<p>这里的难点在于，函数式<code>while_FP</code>循环采用了递归的概念。当<code>&lt;condition&gt;</code>为<code>true</code>时，进入循环体，执行<code>while_block()</code>；若<code>&lt;break_condition&gt;</code>为<code>true</code>时，返回1，<code>while_FP()</code>调用结束；若<code>&lt;break_condition&gt;</code>为<code>false</code>时，返回0，会继续执行<code>or</code>右侧的<code>while_FP()</code>，从而实现递归调用；若<code>&lt;break_condition&gt;</code>始终为<code>false</code>，则会持续递归调用<code>while_FP()</code>，这就实现了<code>while</code>语句中同样的功能。</p>
<p>为了对函数式的<code>while</code>循环有更深刻的理解，可以再看下如下示例。这个例子是在网上找的，实现的是<code>echo</code>功能：输入任意非”quit”字符时，打印输入的字符；输入”quit”字符时，退出程序。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">➜  PythonFP python pyecho.py</div><div class="line">IMP -- 1</div><div class="line">1</div><div class="line">IMP -- 2</div><div class="line">2</div><div class="line">IMP -- abc</div><div class="line">abc</div><div class="line">IMP -- 1 + 1</div><div class="line">1 + 1</div><div class="line">IMP -- quit</div><div class="line">quit</div><div class="line">➜  PythonFP</div></pre></td></tr></table></figure>
<p>如下便是分别采用过程式和函数式语句实现的”echo”功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># imperative version of "echo()"</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_IMP</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">        x = raw_input(<span class="string">"IMP -- "</span>)</div><div class="line">        <span class="keyword">print</span> x</div><div class="line">        <span class="keyword">if</span> x == <span class="string">'quit'</span>:</div><div class="line">            <span class="keyword">break</span></div><div class="line"></div><div class="line">echo_IMP()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">monadic_print</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="keyword">print</span> x</div><div class="line">    <span class="keyword">return</span> x</div><div class="line"></div><div class="line"><span class="comment"># FP version of "echo()"</span></div><div class="line">echo_FP = <span class="keyword">lambda</span>: monadic_print(raw_input(<span class="string">"FP -- "</span>))==<span class="string">'quit'</span> <span class="keyword">or</span> echo_FP()</div><div class="line">echo_FP()</div></pre></td></tr></table></figure>
<h2 id="更多示例"><a href="#更多示例" class="headerlink" title="更多示例"></a>更多示例</h2><p>到此为止，我们对函数式编程总算有了点认识，到达之前设定的目标应该是没有问题了，看来函数式编程也并没有想象中的那么难懂。</p>
<p>然而，这都只是函数式编程的皮毛而已，不信？再看下如下示例。</p>
<p>这个示例也是在网上找的，实现的是两个列表笛卡尔积的筛选功能，找出笛卡尔积元组集合中两个元素之积大于25的所有元组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bigmuls = <span class="keyword">lambda</span> xs,ys: filter(<span class="keyword">lambda</span> (x,y):x*y &gt; <span class="number">25</span>, combine(xs,ys))</div><div class="line">combine = <span class="keyword">lambda</span> xs,ys: map(<span class="keyword">None</span>, xs*len(ys), dupelms(ys,len(xs)))</div><div class="line">dupelms = <span class="keyword">lambda</span> lst,n: reduce(<span class="keyword">lambda</span> s,t:s+t, map(<span class="keyword">lambda</span> l,n=n: [l]*n, lst))</div><div class="line"></div><div class="line"><span class="keyword">print</span> bigmuls([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">10</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">22</span>])</div><div class="line"></div><div class="line">[(<span class="number">3</span>, <span class="number">10</span>), (<span class="number">4</span>, <span class="number">10</span>), (<span class="number">2</span>, <span class="number">15</span>), (<span class="number">3</span>, <span class="number">15</span>), (<span class="number">4</span>, <span class="number">15</span>), (<span class="number">2</span>, <span class="number">22</span>), (<span class="number">3</span>, <span class="number">22</span>), (<span class="number">4</span>, <span class="number">22</span>)]</div></pre></td></tr></table></figure>
<p>虽然这个例子中<code>lambda/map/reduce/filter</code>都是我们已经比较熟悉了的基本单元，但是经过组合后，理解起来还是会比较吃力。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看到这里，有的同学就开玩笑说我这标题名称非常贴切，《Python的函数式编程–从入门到⎡放弃⎦》，因为以后在工作中应该也不会再尝试使用函数式编程了，^_^。</p>
<p>不过，我还是觉得函数式编程挺有意思的，更高级的特性后面值得再继续学习。即使代码不用写成pure函数式风格，但在某些时候局部使用<code>lambda/map/reduce/filter</code>也能大大简化代码，也是一个不错的选择。</p>
<p>另外，通过此次分享，再次切身体会到了教授是最好的学习方式，只有当你真正能将一个概念讲解清楚的时候，你才算是掌握了这个概念。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.ibm.com/developerworks/linux/library/l-prog/index.html" target="_blank" rel="external">http://www.ibm.com/developerworks/linux/library/l-prog/index.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很早以前就听说过了函数式编程，印象中是一种很晦涩难懂的编程模式，但却一直没有去进行了解。&lt;/p&gt;
&lt;p&gt;恰好这周组内的周会轮到我主持，一时也没想到要分享什么。灵光一闪，就选定函数式编程这个主题吧，反正组里的同事都没有学过，只需要讲解入门方面的知识就好，也正好可以借这个机会逼
    
    </summary>
    
    
      <category term="Python" scheme="http://debugtalk.com/tags/Python/"/>
    
      <category term="函数式编程" scheme="http://debugtalk.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>微信朋友圈投票活动的刷票案例分析</title>
    <link href="http://debugtalk.com/post/cheat-in-wechat-moments-voting-activity/"/>
    <id>http://debugtalk.com/post/cheat-in-wechat-moments-voting-activity/</id>
    <published>2016-04-03T16:00:00.000Z</published>
    <updated>2016-07-23T07:31:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>现阶段，在微信朋友圈举办的投票活动层出不穷，相信已经有不少同学对此不胜其烦，因为总会时不时地冒出个人（亲戚、朋友、or whatever）来请你帮TA投票。</p>
<p>本文倒没有打算从道德或者情感层面来探讨这个问题，我所感兴趣的是，当前大多数投票活动其实都是存在明显漏洞的，通过简单的技术手段就可以实现“刷票”。</p>
<h2 id="案例描述"><a href="#案例描述" class="headerlink" title="案例描述"></a>案例描述</h2><p>这里就有一个案例。</p>
<p>某美发网上商城（以下简称S商城）在微信平台上举办了一场在线投票活动，微信用户可通过活动链接访问到投票页面，对喜欢的发型师作品进行投票；每个微信帐号每天只能给单个作品投1张选票。</p>
<p>投票活动页面如下图所示：</p>
<p><img src="/images/voteRobot_01.png" alt=""></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>表面上看，S商城已经对投票活动进行了反作弊处理，因为限制了每个微信用户每天只能投一张票。如果用户都是正常地通过微信访问这个投票服务进行投票的话，的确是能起到预期效果的。</p>
<p>然而，如果查看投票页面的原始地址，即按住页面向下拖动，会发现屏幕顶端显示为”本网页由XXX提供”，需要注意的是，这里的”XXX”并不是”mp.weixin.qq.com”，而是S商城的域名。也就是说，这个投票活动的程序是运行在S商城的服务器上面的。</p>
<p>基于以上分析，可以推断出用户投票操作的网络拓扑结构示意图应该是这样的：</p>
<p><img src="/images/voteRobot_02.png" alt=""></p>
<p>微信用户访问投票页面时，微信服务器只是进行了请求转发，具体的投票计数与校验都是在S商城的服务器上的。</p>
<p>那么，S商城是怎么来区分投票用户的呢？</p>
<p>这里就涉及到微信公众平台<code>OpenID</code>的概念了。官方对<code>OpenID</code>的解释是：加密后的微信号，每个用户对每个公众号的OpenID是唯一的。</p>
<p>要验证这一点也很容易，只需要通过采用多个微信账号进行投票，并对投票过程进行网络抓包，查看POST中的参数就可以证实。</p>
<p>基于这一点，微信公众平台在转发投票请求时，会在POST参数中包含用户的<code>OpenID</code>；S商城在接收到投票的POST请求后，通过查询当前<code>OpenID</code>是否在当天已经投过票，就可以阻止单一用户重复投票的行为了。</p>
<p>然而，这里面却存在一个很大的漏洞！</p>
<p>S商城只能判断<code>OpenID</code>是否出现了重复，但是却无法校验<code>OpenID</code>的有效性，因为它是无法调用微信服务器来对这个<code>OpenID</code>进行校验的。</p>
<h2 id="VoteRobot实现"><a href="#VoteRobot实现" class="headerlink" title="VoteRobot实现"></a>VoteRobot实现</h2><p>明确了这个漏洞后，要实现刷票就很简单了。</p>
<ul>
<li>采用微信用户正常地进行一次投票操作，对设备进行网络抓包，获取到投票过程中HTTP层面的请求参数和响应内容；</li>
<li>使用Fiddler（或Python脚本）构造投票的HTTP POST请求，保持各参数与真实投票时抓取到的参数内容一致；</li>
<li>随机生成不同的<code>OpenID</code>参数，重复进行POST请求。</li>
</ul>
<p>如果要实现批量刷票，或者刷票自动化操作，那么就可以将刷票请求通过Python脚本来实现；甚至，采用LoadRunner也是可以的。</p>
<p>运行<code>VoteRobot.py</code>，输出日志如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">======== Start to vote zpid(38), Total votes: 3</div><div class="line">1 tickets has been voted, the next ticket will be voted after 35 seconds.</div><div class="line">2 tickets has been voted, the next ticket will be voted after 31 seconds.</div><div class="line">3 tickets has been voted, the next ticket will be voted after 10 seconds.</div><div class="line">======== Voting Ended!</div></pre></td></tr></table></figure>
<p>需要注意的是，通常自动化刷票时最好有个随机的时间间隔，并且，最好能动态模拟不同的设备，即修改<code>User-Agent</code>，否则，服务端可以较为容易地识别作弊行为。</p>
<h2 id="作弊与反作弊？"><a href="#作弊与反作弊？" class="headerlink" title="作弊与反作弊？"></a>作弊与反作弊？</h2><p>看到这里，也许有的同学心中窃喜，以后投票都可以采用这种方式“刷票”了么？</p>
<p>很遗憾，当然不是。</p>
<p>其实本文中案例的漏洞是很低级的，只是，当前的确还存在不少比例的投票活动是采用这种模式。</p>
<p>要判断一个投票活动是否可以采用这种方式来作弊也很简单。采用本文中的方法，若查看到活动的网址是非微信官方的，而且整个投票过程也没有额外的校验，那么实现作弊的可能性就很大了；再通过抓包看下通讯交互过程，并用网络请求工具修改参数后重新请求下，即可验证是否真的可以作弊了。</p>
<p>另外，也许有人想问了，网络中的投票活动就没法杜绝“刷票”行为了么？</p>
<p>答案是，完全杜绝的确很难。听说过12306的黄牛党没？听说过Apple Store专业给应用刷榜单的没？听说过“网络水军”、“五毛党”没？</p>
<p>不过，活动举办方可以通过一些手段，大大提高作弊的门槛。例如，当前有不少活动就采用了如下方式：</p>
<ul>
<li>要求投票用户先关注活动举办方的公众号，然后调用微信官方的投票功能；</li>
<li>要求投票用户在投票活动举办方的网站上进行注册（手机号验证、实名验证）</li>
</ul>
<p>不管采用这两种方式中的哪一种，本文中的“刷票”方法就完全失效了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现阶段，在微信朋友圈举办的投票活动层出不穷，相信已经有不少同学对此不胜其烦，因为总会时不时地冒出个人（亲戚、朋友、or whatever）来请你帮TA投票。&lt;/p&gt;
&lt;p&gt;本文倒没有打算从道德或者情感层面来探讨这个问题，我所感兴趣的是，当前大多数投票活动其实都是存在明显漏洞
    
    </summary>
    
    
      <category term="案例分析" scheme="http://debugtalk.com/tags/%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    
      <category term="security" scheme="http://debugtalk.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>测试结果报表展现：Web页面绘制多层级表格</title>
    <link href="http://debugtalk.com/post/render-multi-level-table-in-webpage/"/>
    <id>http://debugtalk.com/post/render-multi-level-table-in-webpage/</id>
    <published>2016-03-19T16:00:00.000Z</published>
    <updated>2016-07-23T07:32:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景描述"><a href="#背景描述" class="headerlink" title="背景描述"></a>背景描述</h2><p>在Android性能测试中，每一个测试任务都对应了1个测试用例、1台测试设备、一个测试包，并且在测试结果中包含了多个指标项。通常，我们希望能对两个不同版本测试包的测试结果进行对比，并能在Web页面上以表格的形式进行展现。</p>
<p>很自然地，我们会想到采用如下形式展现对比结果。</p>
<p>{: .center}<br><img src="/images/render_table_three_levels.png" alt=""><br>图1 三层表格</p>
<p>对应地，采用如下数据结构存储结果数据。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">data_hash = &#123;</div><div class="line">  "pkg_array": ["pkg1", "pkg2"],</div><div class="line">  "data": &#123;</div><div class="line">    "testcase1": &#123;</div><div class="line">      "device1": &#123;</div><div class="line">        "indicator1": ["value1", "value2"],</div><div class="line">        "indicator2": ["value3", "value4"],</div><div class="line">      &#125;,</div><div class="line">      "device2": &#123;</div><div class="line">        "indicator1": ["value5", "value6"],</div><div class="line">        "indicator2": ["value7", "value8"],</div><div class="line">      &#125;,</div><div class="line">    &#125;,</div><div class="line">    "testcase2": &#123;</div><div class="line">      "device1": &#123;</div><div class="line">        "indicator1": ["value9", "value10"],</div><div class="line">        "indicator2": ["value11", "value12"],</div><div class="line">      &#125;,</div><div class="line">      "device2": &#123;</div><div class="line">        "indicator1": ["value13", "value14"],</div><div class="line">        "indicator2": ["value15", "value16"],</div><div class="line">      &#125;,</div><div class="line">    &#125;,</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想法明确了，那要怎么实现呢？</p>
<p>对于像我这样没学过前端的人来说，最难的就是如何通过代码绘制层级表格的问题。</p>
<h2 id="第一次尝试：绘制2层表格"><a href="#第一次尝试：绘制2层表格" class="headerlink" title="第一次尝试：绘制2层表格"></a>第一次尝试：绘制2层表格</h2><p>为了简化问题分析过程，先尝试对两层表格进行绘制。</p>
<p>{: .center}<br><img src="/images/render_table_two_levels.png" alt=""><br>图2 两层表格</p>
<p>简化后的数据结构如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">two_level_data_hash = &#123;</div><div class="line">  "pkg_array": ["pkg1", "pkg2"],</div><div class="line">  "data": &#123;</div><div class="line">    "device1": &#123;</div><div class="line">      "indicator1": ["value1", "value2"],</div><div class="line">      "indicator2": ["value3", "value4"],</div><div class="line">    &#125;,</div><div class="line">    "device2": &#123;</div><div class="line">      "indicator1": ["value5", "value6"],</div><div class="line">      "indicator2": ["value7", "value8"],</div><div class="line">    &#125;,</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上表格对应的html代码如下。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">th</span>&gt;</span>Device<span class="tag">&lt;/<span class="name">th</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">th</span>&gt;</span>Indicator<span class="tag">&lt;/<span class="name">th</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">th</span>&gt;</span>Pkg1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">th</span>&gt;</span>Pkg2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>device1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>indicator1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>value1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>value2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>indicator2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>value3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>value4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以看出，绘制层级表格的关键在于<code>tr</code>和<code>rowspan</code>的控制上。<br>因此，我们可以尝试采用如下JavaScript代码进行生成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render_two_level_table</span>(<span class="params">two_level_data_hash</span>)</span>&#123;</div><div class="line">  pkg_array = two_level_data_hash[<span class="string">"pkg_array"</span>];</div><div class="line">  table_header = <span class="string">"&lt;tr&gt;"</span>;</div><div class="line">  table_header += <span class="string">"&lt;th&gt;Device&lt;/th&gt;&lt;th colspan='1'&gt;Indicator&lt;/th&gt;"</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> pkg_index <span class="keyword">in</span> pkg_array)&#123;</div><div class="line">    table_header += <span class="string">"&lt;th&gt;"</span> + pkg_array[pkg_index] + <span class="string">"&lt;/th&gt;"</span></div><div class="line">  &#125;</div><div class="line">  table_header += <span class="string">"&lt;/tr&gt;"</span>;</div><div class="line"></div><div class="line">  data = two_level_data_hash[<span class="string">"data"</span>];</div><div class="line">  table_body = <span class="string">""</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> device <span class="keyword">in</span> data)&#123;</div><div class="line">    is_first_indicator_row = <span class="literal">true</span>;</div><div class="line">    table_body += <span class="string">"&lt;tr&gt;&lt;td rowspan='"</span> + data[device].length + <span class="string">"'&gt;"</span> + device + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> indicator <span class="keyword">in</span> data[device])&#123;</div><div class="line">      <span class="keyword">if</span>(!is_first_indicator_row)&#123;</div><div class="line">        table_body += <span class="string">"&lt;tr&gt;"</span>;</div><div class="line">      &#125;</div><div class="line">      table_body += <span class="string">"&lt;td&gt;"</span> + indicator + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line">      value_list = data[device][indicator];</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> value_list)&#123;</div><div class="line">        table_body += <span class="string">"&lt;td&gt;"</span> + value_list[index] + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line">      &#125;</div><div class="line">      table_body += <span class="string">"&lt;/tr&gt;"</span>;</div><div class="line">      is_first_indicator_row = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    table_body += <span class="string">"&lt;/tr&gt;"</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  table_content = <span class="string">"&lt;table border='1'&gt;"</span> + table_header + table_body + <span class="string">"&lt;/table&gt;"</span>;</div><div class="line">  $(<span class="string">"#table"</span>).html(table_content);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在绘制indicator单元格的时候，为了判断当前indicator是否是当前device对应的第一个，即是否需要添加<code>&lt;tr&gt;</code>格式符，我们引入了<code>is_first_indicator_row</code>变量；<code>is_first_indicator_row</code>初始为true，绘制完第一个indicator以后变为false；绘制当前device剩余indicator的时候，由于<code>is_first_indicator_row</code>为false，因此每次都会加上<code>&lt;tr&gt;</code>格式符。</p>
<p>在判断device单元格的行跨度(<code>rowspan</code>)时，由于indicator是device的key，因此我们可以通过当前device中key的数量来得到<code>rowspan</code>，即<code>two_level_data_hash[device].length</code>。</p>
<p>绘制下一个device对应的数据时，再重复以上流程。</p>
<p>可以看出，为了正确打印<code>&lt;tr&gt;</code>格式符，我们做了不少工作。两层表格的绘制方法解决了，那如何绘制三层表格呢？</p>
<h2 id="第二次尝试：绘制3层表格"><a href="#第二次尝试：绘制3层表格" class="headerlink" title="第二次尝试：绘制3层表格"></a>第二次尝试：绘制3层表格</h2><p>回到背景描述里面的需求，若按照上面的思路，我们要绘制三层表格时，就需要引入两个变量，<code>is_first_device_row</code>和<code>is_first_indicator_row</code>，分别用于标记device和indicator是否第一次出现。</p>
<p>那对于<code>rowspan</code>呢？这貌似就有点麻烦了。因为我们在绘制testcase单元格的时候，<code>rowspan</code>的取值应该是当前testcase包含的所有device各自包含的indicator的数量总和，而我们并不能像之前的方式那样直接得到这个数值。</p>
<p>那要怎么处理呢？我们可以尝试写一个函数<code>row_num</code>，来计算得到给定JSON数据里面包含的子节点的总数。</p>
<p>实现方式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render_three_level_table</span>(<span class="params">data_hash</span>)</span>&#123;</div><div class="line">  pkg_array = data_hash[<span class="string">"pkg_array"</span>];</div><div class="line">  table_header = <span class="string">"&lt;tr&gt;"</span>;</div><div class="line">  table_header += <span class="string">"&lt;th&gt;TestCase&lt;/th&gt;&lt;th&gt;Device&lt;/th&gt;&lt;th colspan='1'&gt;Indicator&lt;/th&gt;"</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> pkg_index <span class="keyword">in</span> pkg_array)&#123;</div><div class="line">    table_header += <span class="string">"&lt;th&gt;"</span> + pkg_array[pkg_index] + <span class="string">"&lt;/th&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  table_header += <span class="string">"&lt;/tr&gt;"</span>;</div><div class="line"></div><div class="line">  data = data_hash[<span class="string">"data"</span>];</div><div class="line">  table_body = <span class="string">""</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> testcase <span class="keyword">in</span> data)&#123;</div><div class="line">    is_first_row_device = <span class="literal">true</span>;</div><div class="line">    table_body += <span class="string">"&lt;tr&gt;&lt;td rowspan='"</span> + row_num(data[testcase]) + <span class="string">"'&gt;"</span> + testcase + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> device <span class="keyword">in</span> data[testcase])&#123;</div><div class="line">      <span class="keyword">if</span>(!is_first_row_device)&#123;</div><div class="line">        table_body += <span class="string">"&lt;tr&gt;"</span>;</div><div class="line">      &#125;</div><div class="line">      table_body += <span class="string">"&lt;td rowspan='"</span> + row_num(data[testcase][device]) + <span class="string">"'&gt;"</span> + device + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line"></div><div class="line">      is_first_row_indicator = <span class="literal">true</span>;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> indicator <span class="keyword">in</span> data[testcase][device])&#123;</div><div class="line">        <span class="keyword">if</span>(!is_first_row_indicator)&#123;</div><div class="line">          table_body += <span class="string">"&lt;tr&gt;"</span>;</div><div class="line">        &#125;</div><div class="line">        table_body += <span class="string">"&lt;td&gt;"</span> + indicator + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line"></div><div class="line">        value_list = data[testcase][device][indicator];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> value_list)&#123;</div><div class="line">          table_body += <span class="string">"&lt;td&gt;"</span> + value_list[index] + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line">        &#125;</div><div class="line">        table_body += <span class="string">"&lt;/tr&gt;"</span>;</div><div class="line">      &#125;</div><div class="line">      table_body += <span class="string">"&lt;/tr&gt;"</span>;</div><div class="line">      is_first_row_indicator = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    table_body += <span class="string">"&lt;/tr&gt;"</span>;</div><div class="line">    is_first_row_device = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  table_content = <span class="string">"&lt;table border='1'&gt;"</span> + table_header + table_body + <span class="string">"&lt;/table&gt;"</span>;</div><div class="line">  $(<span class="string">"#table"</span>).html(table_content);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">row_num</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> counter = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span>(data.constructor == <span class="built_in">Array</span>)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(key <span class="keyword">in</span> data)&#123;</div><div class="line">    <span class="keyword">var</span> tmp = data[key];</div><div class="line">    <span class="keyword">if</span>(tmp.constructor == <span class="built_in">Array</span>)</div><div class="line">    &#123;</div><div class="line">      counter += <span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      counter += row_num(tmp);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> counter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在计算<code>rowspan</code>时，我们用到了递归的方法，实现了对当前testcase或当前device所对应的indicator总数的计算。</p>
<p>通过以上方式，我们实现了三层表格的绘制。可以看出，三层表格的判断逻辑比两层表格复杂了很多，那如果我们还想绘制更多层次的表格呢？显然，这种方法已不再适用，我们不可能每增加一层就新增加一个标识变量，而且对于数据层级不固定的情况，采用这种方式是完全无法实现自适应的。</p>
<h2 id="重构：递归！"><a href="#重构：递归！" class="headerlink" title="重构：递归！"></a>重构：递归！</h2><p>回顾上面的代码，我们不难发现，三层表格的代码相比于两层表格的代码，存在着不少重复，而且可以预见，如果我们采用同样的方式去绘制更多层次表格的话，重复的代码会出现得更多。</p>
<p>一定有更简洁的方法！对，递归！</p>
<p>其实刚才我们在计算<code>rowspan</code>时已经体会到了递归的好处，它可以自适应多层次的数据结构。我们也完全可以将这个思想应用到表格层级的绘制上面。</p>
<p>观察背景描述中的数据结构，不难发现，对比数据存储于Array中，而中间层的value都是Hash结构，因此，我们可以通过这个区别，编写递归调用方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">render_table</span>(<span class="params">data_hash</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> res = <span class="string">""</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> data_hash)&#123;</div><div class="line">    <span class="keyword">var</span> tmp = data_hash[key];</div><div class="line">    <span class="keyword">if</span>(tmp.constructor == <span class="built_in">Array</span>)</div><div class="line">    &#123;</div><div class="line">      res += <span class="string">"&lt;tr&gt;&lt;td rowspan='"</span> + row_num(tmp)+ <span class="string">"'&gt;"</span> + key + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line">      <span class="keyword">for</span>(value_index <span class="keyword">in</span> tmp)&#123;</div><div class="line">        <span class="keyword">var</span> value = tmp[value_index];</div><div class="line">        res += <span class="string">"&lt;td&gt;"</span> + value + <span class="string">"&lt;/td&gt;"</span>;</div><div class="line">      &#125;</div><div class="line">      res += <span class="string">"&lt;/tr&gt;"</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      res += <span class="string">"&lt;tr&gt;&lt;td rowspan='"</span> + row_num(tmp) + <span class="string">"'&gt;"</span> + key + <span class="string">"&lt;/td&gt;"</span> + <span class="string">"&lt;/tr&gt;"</span>;</div><div class="line">      res += render_table(tmp);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">row_num</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> counter = <span class="number">1</span>;</div><div class="line">  <span class="keyword">if</span>(data.constructor == <span class="built_in">Array</span>)&#123;</div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(key <span class="keyword">in</span> data)&#123;</div><div class="line">    <span class="keyword">var</span> tmp = data[key];</div><div class="line">    <span class="keyword">if</span>(tmp.constructor == <span class="built_in">Array</span>)</div><div class="line">    &#123;</div><div class="line">      counter += <span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      counter += row_num(tmp);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> counter;</div><div class="line">&#125;</div><div class="line"></div><div class="line">table_body = <span class="string">""</span>;</div><div class="line">table_body += render_table(data_hash);</div></pre></td></tr></table></figure>
<p>采用了递归的方式以后，我们就不用再关注表格的层级了，只要是传入数据的数据结构与背景描述里面的类似，那么就可以自动绘制出任意层级的表格。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景描述&quot;&gt;&lt;a href=&quot;#背景描述&quot; class=&quot;headerlink&quot; title=&quot;背景描述&quot;&gt;&lt;/a&gt;背景描述&lt;/h2&gt;&lt;p&gt;在Android性能测试中，每一个测试任务都对应了1个测试用例、1台测试设备、一个测试包，并且在测试结果中包含了多个指标项。
    
    </summary>
    
    
      <category term="报表" scheme="http://debugtalk.com/tags/%E6%8A%A5%E8%A1%A8/"/>
    
      <category term="Javascript" scheme="http://debugtalk.com/tags/Javascript/"/>
    
  </entry>
  
</feed>
